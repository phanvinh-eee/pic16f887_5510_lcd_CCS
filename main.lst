CCS PCM C Compiler, Version 5.015, 5967               14-Apr-16 14:10

               Filename:   D:\pic\project\pic_ds1302_lcd84x48_1.0\main.lst

               ROM used:   4591 words (56%)
                           Largest free fragment is 2048
               RAM used:   57 (15%) at main() level
                           71 (19%) worst case
               Stack used: 8 locations
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   69E
0003:  NOP
.................... #include <main.h> 
.................... #include <16F887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  00
0009:  RETLW  00
000A:  RETLW  00
000B:  RETLW  00
000C:  RETLW  00
000D:  RETLW  00
000E:  RETLW  00
000F:  RETLW  5F
0010:  RETLW  00
0011:  RETLW  00
0012:  RETLW  00
0013:  RETLW  07
0014:  RETLW  00
0015:  RETLW  07
0016:  RETLW  00
0017:  RETLW  14
0018:  RETLW  7F
0019:  RETLW  14
001A:  RETLW  7F
001B:  RETLW  14
001C:  RETLW  24
001D:  RETLW  2A
001E:  RETLW  7F
001F:  RETLW  2A
0020:  RETLW  12
0021:  RETLW  23
0022:  RETLW  13
0023:  RETLW  08
0024:  RETLW  64
0025:  RETLW  62
0026:  RETLW  36
0027:  RETLW  49
0028:  RETLW  55
0029:  RETLW  22
002A:  RETLW  50
002B:  RETLW  00
002C:  RETLW  05
002D:  RETLW  03
002E:  RETLW  00
002F:  RETLW  00
0030:  RETLW  00
0031:  RETLW  1C
0032:  RETLW  22
0033:  RETLW  41
0034:  RETLW  00
0035:  RETLW  00
0036:  RETLW  41
0037:  RETLW  22
0038:  RETLW  1C
0039:  RETLW  00
003A:  RETLW  14
003B:  RETLW  08
003C:  RETLW  3E
003D:  RETLW  08
003E:  RETLW  14
003F:  RETLW  08
0040:  RETLW  08
0041:  RETLW  3E
0042:  RETLW  08
0043:  RETLW  08
0044:  RETLW  00
0045:  RETLW  50
0046:  RETLW  30
0047:  RETLW  00
0048:  RETLW  00
0049:  RETLW  08
004A:  RETLW  08
004B:  RETLW  08
004C:  RETLW  08
004D:  RETLW  08
004E:  RETLW  00
004F:  RETLW  60
0050:  RETLW  60
0051:  RETLW  00
0052:  RETLW  00
0053:  RETLW  20
0054:  RETLW  10
0055:  RETLW  08
0056:  RETLW  04
0057:  RETLW  02
0058:  RETLW  3E
0059:  RETLW  51
005A:  RETLW  49
005B:  RETLW  45
005C:  RETLW  3E
005D:  RETLW  00
005E:  RETLW  42
005F:  RETLW  7F
0060:  RETLW  40
0061:  RETLW  00
0062:  RETLW  42
0063:  RETLW  61
0064:  RETLW  51
0065:  RETLW  49
0066:  RETLW  46
0067:  RETLW  21
0068:  RETLW  41
0069:  RETLW  45
006A:  RETLW  4B
006B:  RETLW  31
006C:  RETLW  18
006D:  RETLW  14
006E:  RETLW  12
006F:  RETLW  7F
0070:  RETLW  10
0071:  RETLW  27
0072:  RETLW  45
0073:  RETLW  45
0074:  RETLW  45
0075:  RETLW  39
0076:  RETLW  3C
0077:  RETLW  4A
0078:  RETLW  49
0079:  RETLW  49
007A:  RETLW  30
007B:  RETLW  01
007C:  RETLW  71
007D:  RETLW  09
007E:  RETLW  05
007F:  RETLW  03
0080:  RETLW  36
0081:  RETLW  49
0082:  RETLW  49
0083:  RETLW  49
0084:  RETLW  36
0085:  RETLW  06
0086:  RETLW  49
0087:  RETLW  49
0088:  RETLW  29
0089:  RETLW  1E
008A:  RETLW  00
008B:  RETLW  36
008C:  RETLW  36
008D:  RETLW  00
008E:  RETLW  00
008F:  RETLW  00
0090:  RETLW  56
0091:  RETLW  36
0092:  RETLW  00
0093:  RETLW  00
0094:  RETLW  08
0095:  RETLW  14
0096:  RETLW  22
0097:  RETLW  41
0098:  RETLW  00
0099:  RETLW  14
009A:  RETLW  14
009B:  RETLW  14
009C:  RETLW  14
009D:  RETLW  14
009E:  RETLW  00
009F:  RETLW  41
00A0:  RETLW  22
00A1:  RETLW  14
00A2:  RETLW  08
00A3:  RETLW  02
00A4:  RETLW  01
00A5:  RETLW  51
00A6:  RETLW  09
00A7:  RETLW  06
00A8:  RETLW  32
00A9:  RETLW  49
00AA:  RETLW  79
00AB:  RETLW  41
00AC:  RETLW  3E
00AD:  RETLW  7E
00AE:  RETLW  11
00AF:  RETLW  11
00B0:  RETLW  11
00B1:  RETLW  7E
00B2:  RETLW  7F
00B3:  RETLW  49
00B4:  RETLW  49
00B5:  RETLW  49
00B6:  RETLW  36
00B7:  RETLW  3E
00B8:  RETLW  41
00B9:  RETLW  41
00BA:  RETLW  41
00BB:  RETLW  22
00BC:  RETLW  7F
00BD:  RETLW  41
00BE:  RETLW  41
00BF:  RETLW  22
00C0:  RETLW  1C
00C1:  RETLW  7F
00C2:  RETLW  49
00C3:  RETLW  49
00C4:  RETLW  49
00C5:  RETLW  41
00C6:  RETLW  7F
00C7:  RETLW  09
00C8:  RETLW  09
00C9:  RETLW  09
00CA:  RETLW  01
00CB:  RETLW  3E
00CC:  RETLW  41
00CD:  RETLW  49
00CE:  RETLW  49
00CF:  RETLW  7A
00D0:  RETLW  7F
00D1:  RETLW  08
00D2:  RETLW  08
00D3:  RETLW  08
00D4:  RETLW  7F
00D5:  RETLW  00
00D6:  RETLW  41
00D7:  RETLW  7F
00D8:  RETLW  41
00D9:  RETLW  00
00DA:  RETLW  20
00DB:  RETLW  40
00DC:  RETLW  41
00DD:  RETLW  3F
00DE:  RETLW  01
00DF:  RETLW  7F
00E0:  RETLW  08
00E1:  RETLW  14
00E2:  RETLW  22
00E3:  RETLW  41
00E4:  RETLW  7F
00E5:  RETLW  40
00E6:  RETLW  40
00E7:  RETLW  40
00E8:  RETLW  40
00E9:  RETLW  7F
00EA:  RETLW  02
00EB:  RETLW  0C
00EC:  RETLW  02
00ED:  RETLW  7F
00EE:  RETLW  7F
00EF:  RETLW  04
00F0:  RETLW  08
00F1:  RETLW  10
00F2:  RETLW  7F
00F3:  RETLW  3E
00F4:  RETLW  41
00F5:  RETLW  41
00F6:  RETLW  41
00F7:  RETLW  3E
00F8:  NOP
00F9:  NOP
00FA:  NOP
00FB:  BSF    0A.0
00FC:  BCF    0A.1
00FD:  BCF    0A.2
00FE:  ADDLW  02
00FF:  BTFSC  03.0
0100:  INCF   0A,F
0101:  MOVWF  02
0102:  RETLW  7F
0103:  RETLW  09
0104:  RETLW  09
0105:  RETLW  09
0106:  RETLW  06
0107:  RETLW  3E
0108:  RETLW  41
0109:  RETLW  51
010A:  RETLW  21
010B:  RETLW  5E
010C:  RETLW  7F
010D:  RETLW  09
010E:  RETLW  19
010F:  RETLW  29
0110:  RETLW  46
0111:  RETLW  46
0112:  RETLW  49
0113:  RETLW  49
0114:  RETLW  49
0115:  RETLW  31
0116:  RETLW  01
0117:  RETLW  01
0118:  RETLW  7F
0119:  RETLW  01
011A:  RETLW  01
011B:  RETLW  3F
011C:  RETLW  40
011D:  RETLW  40
011E:  RETLW  40
011F:  RETLW  3F
0120:  RETLW  1F
0121:  RETLW  20
0122:  RETLW  40
0123:  RETLW  20
0124:  RETLW  1F
0125:  RETLW  3F
0126:  RETLW  40
0127:  RETLW  38
0128:  RETLW  40
0129:  RETLW  3F
012A:  RETLW  63
012B:  RETLW  14
012C:  RETLW  08
012D:  RETLW  14
012E:  RETLW  63
012F:  RETLW  07
0130:  RETLW  08
0131:  RETLW  70
0132:  RETLW  08
0133:  RETLW  07
0134:  RETLW  61
0135:  RETLW  51
0136:  RETLW  49
0137:  RETLW  45
0138:  RETLW  43
0139:  RETLW  00
013A:  RETLW  7F
013B:  RETLW  41
013C:  RETLW  41
013D:  RETLW  00
013E:  RETLW  02
013F:  RETLW  04
0140:  RETLW  08
0141:  RETLW  10
0142:  RETLW  20
0143:  RETLW  00
0144:  RETLW  41
0145:  RETLW  41
0146:  RETLW  7F
0147:  RETLW  00
0148:  RETLW  04
0149:  RETLW  02
014A:  RETLW  01
014B:  RETLW  02
014C:  RETLW  04
014D:  RETLW  40
014E:  RETLW  40
014F:  RETLW  40
0150:  RETLW  40
0151:  RETLW  40
0152:  RETLW  00
0153:  RETLW  01
0154:  RETLW  02
0155:  RETLW  04
0156:  RETLW  00
0157:  RETLW  20
0158:  RETLW  54
0159:  RETLW  54
015A:  RETLW  54
015B:  RETLW  78
015C:  RETLW  7F
015D:  RETLW  48
015E:  RETLW  44
015F:  RETLW  44
0160:  RETLW  38
0161:  RETLW  38
0162:  RETLW  44
0163:  RETLW  44
0164:  RETLW  44
0165:  RETLW  20
0166:  RETLW  38
0167:  RETLW  44
0168:  RETLW  44
0169:  RETLW  48
016A:  RETLW  7F
016B:  RETLW  38
016C:  RETLW  54
016D:  RETLW  54
016E:  RETLW  54
016F:  RETLW  18
0170:  RETLW  08
0171:  RETLW  7E
0172:  RETLW  09
0173:  RETLW  01
0174:  RETLW  02
0175:  RETLW  0C
0176:  RETLW  52
0177:  RETLW  52
0178:  RETLW  52
0179:  RETLW  3E
017A:  RETLW  7F
017B:  RETLW  08
017C:  RETLW  04
017D:  RETLW  04
017E:  RETLW  78
017F:  RETLW  00
0180:  RETLW  44
0181:  RETLW  7D
0182:  RETLW  40
0183:  RETLW  00
0184:  RETLW  20
0185:  RETLW  40
0186:  RETLW  44
0187:  RETLW  3D
0188:  RETLW  00
0189:  RETLW  7F
018A:  RETLW  10
018B:  RETLW  28
018C:  RETLW  44
018D:  RETLW  00
018E:  RETLW  00
018F:  RETLW  41
0190:  RETLW  7F
0191:  RETLW  40
0192:  RETLW  00
0193:  RETLW  7C
0194:  RETLW  04
0195:  RETLW  18
0196:  RETLW  04
0197:  RETLW  78
0198:  RETLW  7C
0199:  RETLW  08
019A:  RETLW  04
019B:  RETLW  04
019C:  RETLW  78
019D:  RETLW  38
019E:  RETLW  44
019F:  RETLW  44
01A0:  RETLW  44
01A1:  RETLW  38
01A2:  RETLW  7C
01A3:  RETLW  14
01A4:  RETLW  14
01A5:  RETLW  14
01A6:  RETLW  08
01A7:  RETLW  08
01A8:  RETLW  14
01A9:  RETLW  14
01AA:  RETLW  18
01AB:  RETLW  7C
01AC:  RETLW  7C
01AD:  RETLW  08
01AE:  RETLW  04
01AF:  RETLW  04
01B0:  RETLW  08
01B1:  RETLW  48
01B2:  RETLW  54
01B3:  RETLW  54
01B4:  RETLW  54
01B5:  RETLW  20
01B6:  RETLW  04
01B7:  RETLW  3F
01B8:  RETLW  44
01B9:  RETLW  40
01BA:  RETLW  20
01BB:  RETLW  3C
01BC:  RETLW  40
01BD:  RETLW  40
01BE:  RETLW  20
01BF:  RETLW  7C
01C0:  RETLW  1C
01C1:  RETLW  20
01C2:  RETLW  40
01C3:  RETLW  20
01C4:  RETLW  1C
01C5:  RETLW  3C
01C6:  RETLW  40
01C7:  RETLW  30
01C8:  RETLW  40
01C9:  RETLW  3C
01CA:  RETLW  44
01CB:  RETLW  28
01CC:  RETLW  10
01CD:  RETLW  28
01CE:  RETLW  44
01CF:  RETLW  0C
01D0:  RETLW  50
01D1:  RETLW  50
01D2:  RETLW  50
01D3:  RETLW  3C
01D4:  RETLW  44
01D5:  RETLW  64
01D6:  RETLW  54
01D7:  RETLW  4C
01D8:  RETLW  44
01D9:  RETLW  00
01DA:  RETLW  08
01DB:  RETLW  36
01DC:  RETLW  41
01DD:  RETLW  00
01DE:  RETLW  00
01DF:  RETLW  00
01E0:  RETLW  7F
01E1:  RETLW  00
01E2:  RETLW  00
01E3:  RETLW  00
01E4:  RETLW  41
01E5:  RETLW  36
01E6:  RETLW  08
01E7:  RETLW  00
01E8:  RETLW  00
01E9:  RETLW  00
01EA:  RETLW  07
01EB:  RETLW  05
01EC:  RETLW  07
01ED:  RETLW  78
01EE:  RETLW  46
01EF:  RETLW  41
01F0:  RETLW  46
01F1:  RETLW  78
01F2:  BSF    0A.0
01F3:  BCF    0A.1
01F4:  BCF    0A.2
01F5:  ADDWF  02,F
01F6:  RETLW  01
01F7:  RETLW  02
01F8:  RETLW  03
01F9:  RETLW  04
01FA:  RETLW  05
01FB:  DATA 41,26
01FC:  DATA 41,29
01FD:  DATA 4D,10
01FE:  DATA D2,24
01FF:  DATA CE,23
0200:  DATA 21,00
0201:  DATA 41,26
0202:  DATA 41,29
0203:  DATA 4D,10
0204:  DATA D3,22
0205:  DATA 54,2A
0206:  DATA 49,27
0207:  DATA 47,00
0208:  DATA 41,26
0209:  DATA 41,29
020A:  DATA 4D,10
020B:  DATA 25,32
020C:  DATA 20,10
020D:  DATA 20,10
020E:  DATA 20,10
020F:  DATA 20,00
0210:  DATA 41,26
0211:  DATA 41,29
0212:  DATA 4D,10
0213:  DATA 25,32
0214:  DATA 00,00
0215:  DATA 41,26
0216:  DATA 41,29
0217:  DATA 4D,10
0218:  DATA 25,32
0219:  DATA 20,10
021A:  DATA 20,10
021B:  DATA 20,10
021C:  DATA 20,00
021D:  DATA 41,26
021E:  DATA 41,29
021F:  DATA 4D,10
0220:  DATA 25,32
0221:  DATA 00,00
0222:  DATA CD,22
0223:  DATA CE,2A
0224:  DATA 00,01
0225:  DATA CF,25
0226:  DATA 20,10
0227:  DATA 20,10
0228:  DATA 20,10
0229:  DATA 20,10
022A:  DATA C2,20
022B:  DATA C3,25
022C:  DATA 00,01
022D:  DATA CF,25
022E:  DATA 20,10
022F:  DATA 20,10
0230:  DATA 20,10
0231:  DATA 20,10
0232:  DATA CE,22
0233:  DATA 58,2A
0234:  DATA 00,01
0235:  DATA D3,30
0236:  DATA F6,32
0237:  DATA A0,3C
0238:  DATA EF,3A
0239:  DATA 72,10
023A:  DATA 20,10
023B:  DATA 20,10
023C:  DATA 63,34
023D:  DATA 61,37
023E:  DATA E7,32
023F:  DATA 3F,00
0240:  DATA CF,25
0241:  DATA 20,10
0242:  DATA 20,10
0243:  DATA 20,10
0244:  DATA C3,20
0245:  DATA CE,21
0246:  DATA 45,26
0247:  DATA 00,00
0248:  DATA 2F,19
0249:  DATA 30,18
024A:  DATA 25,32
024B:  DATA 00,01
024C:  DATA 41,26
024D:  DATA 41,29
024E:  DATA 4D,10
024F:  DATA 4F,27
0250:  DATA 00,01
0251:  DATA 41,26
0252:  DATA 41,29
0253:  DATA 4D,10
0254:  DATA 4F,23
0255:  DATA 46,00
0256:  DATA 20,10
0257:  DATA A0,29
0258:  DATA 45,2A
0259:  DATA D4,24
025A:  DATA CE,23
025B:  DATA 53,10
025C:  DATA 20,10
025D:  DATA 00,01
025E:  DATA 41,32
025F:  DATA EA,3A
0260:  DATA 73,3A
0261:  DATA 20,3A
0262:  DATA E9,36
0263:  DATA 65,10
0264:  DATA 20,10
0265:  DATA 00,00
0266:  DATA 41,32
0267:  DATA EA,3A
0268:  DATA 73,3A
0269:  DATA 20,3A
026A:  DATA E9,36
026B:  DATA 65,00
026C:  DATA 41,32
026D:  DATA EA,3A
026E:  DATA 73,3A
026F:  DATA 20,32
0270:  DATA 61,3A
0271:  DATA 65,10
0272:  DATA 20,10
0273:  DATA 00,01
0274:  DATA 41,32
0275:  DATA EA,3A
0276:  DATA 73,3A
0277:  DATA 20,32
0278:  DATA 61,3A
0279:  DATA 65,00
027A:  DATA D3,32
027B:  DATA 74,10
027C:  DATA 61,36
027D:  DATA 61,39
027E:  DATA 6D,10
027F:  DATA 20,10
0280:  DATA 20,10
0281:  DATA 00,01
0282:  DATA D3,32
0283:  DATA 74,10
0284:  DATA 61,36
0285:  DATA 61,39
0286:  DATA 6D,00
0287:  DATA D4,34
0288:  DATA ED,32
0289:  DATA A0,3B
028A:  DATA E1,39
028B:  DATA A0,39
028C:  DATA 61,3B
028D:  DATA 65,32
028E:  DATA 00,01
028F:  DATA C4,30
0290:  DATA F4,32
0291:  DATA A0,3B
0292:  DATA E1,39
0293:  DATA A0,39
0294:  DATA 61,3B
0295:  DATA 65,32
0296:  DATA 00,01
0297:  DATA 41,36
0298:  DATA 61,39
0299:  DATA 6D,10
029A:  DATA F7,30
029B:  DATA 73,10
029C:  DATA F3,32
029D:  DATA 74,00
029E:  DATA 54,34
029F:  DATA 65,10
02A0:  DATA E1,31
02A1:  DATA F4,34
02A2:  DATA 6F,37
02A3:  DATA A0,3B
02A4:  DATA E1,39
02A5:  DATA A0,39
02A6:  DATA 61,3B
02A7:  DATA 65,32
02A8:  DATA A0,34
02A9:  DATA 6E,10
02AA:  DATA 53,22
02AB:  DATA 20,10
02AC:  DATA A0,31
02AD:  DATA 61,39
02AE:  DATA 64,00
02AF:  DATA A0,22
02B0:  DATA C4,24
02B1:  DATA 54,10
02B2:  DATA 41,26
02B3:  DATA 41,29
02B4:  DATA 4D,10
02B5:  DATA 25,32
02B6:  DATA 20,00
02B7:  DATA D3,32
02B8:  DATA 74,10
02B9:  DATA 61,36
02BA:  DATA 61,39
02BB:  DATA 6D,10
02BC:  DATA 6F,37
02BD:  DATA 20,00
02BE:  DATA D3,32
02BF:  DATA 74,10
02C0:  DATA 61,36
02C1:  DATA 61,39
02C2:  DATA 6D,10
02C3:  DATA 6F,33
02C4:  DATA 66,00
02C5:  DATA D3,32
02C6:  DATA 74,10
02C7:  DATA 61,36
02C8:  DATA 61,39
02C9:  DATA 6D,10
02CA:  DATA 6F,37
02CB:  DATA 20,00
02CC:  DATA D3,32
02CD:  DATA 74,10
02CE:  DATA 61,36
02CF:  DATA 61,39
02D0:  DATA 6D,10
02D1:  DATA 6F,33
02D2:  DATA 66,00
02D3:  DATA A0,22
02D4:  DATA C4,24
02D5:  DATA 54,10
02D6:  DATA 41,26
02D7:  DATA 41,29
02D8:  DATA 4D,10
02D9:  DATA 25,32
02DA:  DATA 20,00
02DB:  DATA 41,36
02DC:  DATA 61,39
02DD:  DATA 6D,10
02DE:  DATA 6F,37
02DF:  DATA 00,01
02E0:  DATA 41,36
02E1:  DATA 61,39
02E2:  DATA 6D,10
02E3:  DATA 6F,33
02E4:  DATA 66,00
02E5:  DATA 20,10
02E6:  DATA A0,22
02E7:  DATA C4,24
02E8:  DATA 54,10
02E9:  DATA C4,20
02EA:  DATA D4,22
02EB:  DATA 20,10
02EC:  DATA 20,00
02ED:  DATA D3,3A
02EE:  DATA 6E,32
02EF:  DATA E1,3C
02F0:  DATA 20,10
02F1:  DATA 20,10
02F2:  DATA 20,10
02F3:  DATA 20,10
02F4:  DATA 00,01
02F5:  DATA CD,37
02F6:  DATA 6E,32
02F7:  DATA E1,3C
02F8:  DATA 20,10
02F9:  DATA 20,10
02FA:  DATA 20,10
02FB:  DATA 20,10
02FC:  DATA 00,01
02FD:  DATA D4,3A
02FE:  DATA E5,39
02FF:  DATA E4,30
0300:  DATA 79,10
0301:  DATA 20,10
0302:  DATA 20,10
0303:  DATA 20,10
0304:  DATA 00,01
0305:  DATA D7,32
0306:  DATA 64,37
0307:  DATA E5,39
0308:  DATA 6E,32
0309:  DATA E1,3C
030A:  DATA 20,10
030B:  DATA 20,10
030C:  DATA 00,01
030D:  DATA 54,34
030E:  DATA 75,39
030F:  DATA 73,32
0310:  DATA E1,3C
0311:  DATA 20,10
0312:  DATA 20,10
0313:  DATA 20,10
0314:  DATA 00,01
0315:  DATA 46,39
0316:  DATA 69,32
0317:  DATA E1,3C
0318:  DATA 20,10
0319:  DATA 20,10
031A:  DATA 20,10
031B:  DATA 20,10
031C:  DATA 00,01
031D:  DATA D3,30
031E:  DATA F4,3A
031F:  DATA 72,32
0320:  DATA E1,3C
0321:  DATA 20,10
0322:  DATA 20,10
0323:  DATA 20,10
0324:  DATA 00,01
0325:  DATA D3,3A
0326:  DATA 6E,32
0327:  DATA E1,3C
0328:  DATA 20,10
0329:  DATA 20,10
032A:  DATA 20,10
032B:  DATA 20,10
032C:  DATA 20,00
032D:  DATA CD,37
032E:  DATA 6E,32
032F:  DATA E1,3C
0330:  DATA 20,10
0331:  DATA 20,10
0332:  DATA 20,10
0333:  DATA 20,10
0334:  DATA 20,00
0335:  DATA D4,3A
0336:  DATA E5,39
0337:  DATA E4,30
0338:  DATA 79,10
0339:  DATA 20,10
033A:  DATA 20,10
033B:  DATA 20,10
033C:  DATA 20,00
033D:  DATA D7,32
033E:  DATA 64,37
033F:  DATA E5,39
0340:  DATA 6E,32
0341:  DATA E1,3C
0342:  DATA 20,10
0343:  DATA 20,10
0344:  DATA 20,00
0345:  DATA 54,34
0346:  DATA 75,39
0347:  DATA 73,32
0348:  DATA E1,3C
0349:  DATA 20,10
034A:  DATA 20,10
034B:  DATA 20,10
034C:  DATA 20,00
034D:  DATA 46,39
034E:  DATA 69,32
034F:  DATA E1,3C
0350:  DATA 20,10
0351:  DATA 20,10
0352:  DATA 20,10
0353:  DATA 20,10
0354:  DATA 20,00
0355:  DATA D3,30
0356:  DATA F4,3A
0357:  DATA 72,32
0358:  DATA E1,3C
0359:  DATA 20,10
035A:  DATA 20,10
035B:  DATA 20,10
035C:  DATA 20,00
*
048A:  CLRF   77
048B:  CLRF   78
048C:  MOVF   60,W
048D:  BCF    03.0
048E:  BTFSC  61.0
048F:  ADDWF  77,F
0490:  RRF    77,F
0491:  RRF    78,F
0492:  BTFSC  61.1
0493:  ADDWF  77,F
0494:  RRF    77,F
0495:  RRF    78,F
0496:  BTFSC  61.2
0497:  ADDWF  77,F
0498:  RRF    77,F
0499:  RRF    78,F
049A:  BTFSC  61.3
049B:  ADDWF  77,F
049C:  RRF    77,F
049D:  RRF    78,F
049E:  BTFSC  61.4
049F:  ADDWF  77,F
04A0:  RRF    77,F
04A1:  RRF    78,F
04A2:  BTFSC  61.5
04A3:  ADDWF  77,F
04A4:  RRF    77,F
04A5:  RRF    78,F
04A6:  BTFSC  61.6
04A7:  ADDWF  77,F
04A8:  RRF    77,F
04A9:  RRF    78,F
04AA:  BTFSC  61.7
04AB:  ADDWF  77,F
04AC:  RRF    77,F
04AD:  RRF    78,F
04AE:  RETURN
*
04FE:  MOVF   0B,W
04FF:  MOVWF  58
0500:  BCF    0B.7
0501:  BSF    03.5
0502:  BSF    03.6
0503:  BSF    0C.7
0504:  BSF    0C.0
0505:  NOP
0506:  NOP
0507:  BCF    03.5
0508:  BCF    03.6
0509:  BTFSC  58.7
050A:  BSF    0B.7
050B:  BSF    03.6
050C:  MOVF   0C,W
050D:  ANDLW  7F
050E:  BTFSC  03.2
050F:  GOTO   552
0510:  BCF    03.6
0511:  MOVWF  58
0512:  BSF    03.6
0513:  MOVF   0D,W
0514:  BCF    03.6
0515:  MOVWF  59
0516:  BSF    03.6
0517:  MOVF   0F,W
0518:  BCF    03.6
0519:  MOVWF  5A
051A:  MOVF   58,W
051B:  MOVWF  5D
051C:  CALL   4C3
051D:  MOVF   59,W
051E:  BSF    03.6
051F:  MOVWF  0D
0520:  BCF    03.6
0521:  MOVF   5A,W
0522:  BSF    03.6
0523:  MOVWF  0F
0524:  BCF    03.6
0525:  MOVF   0B,W
0526:  MOVWF  5B
0527:  BCF    0B.7
0528:  BSF    03.5
0529:  BSF    03.6
052A:  BSF    0C.7
052B:  BSF    0C.0
052C:  NOP
052D:  NOP
052E:  BCF    03.5
052F:  BCF    03.6
0530:  BTFSC  5B.7
0531:  BSF    0B.7
0532:  BSF    03.6
0533:  RLF    0C,W
0534:  RLF    0E,W
0535:  ANDLW  7F
0536:  BTFSC  03.2
0537:  GOTO   552
0538:  BCF    03.6
0539:  MOVWF  58
053A:  BSF    03.6
053B:  MOVF   0D,W
053C:  BCF    03.6
053D:  MOVWF  59
053E:  BSF    03.6
053F:  MOVF   0F,W
0540:  BCF    03.6
0541:  MOVWF  5A
0542:  MOVF   58,W
0543:  MOVWF  5D
0544:  CALL   4C3
0545:  MOVF   59,W
0546:  BSF    03.6
0547:  MOVWF  0D
0548:  BCF    03.6
0549:  MOVF   5A,W
054A:  BSF    03.6
054B:  MOVWF  0F
054C:  INCF   0D,F
054D:  BTFSC  03.2
054E:  INCF   0F,F
054F:  BCF    03.6
0550:  GOTO   4FE
0551:  BSF    03.6
0552:  BCF    03.6
0553:  RETURN
*
0589:  MOVF   5E,W
058A:  CLRF   78
058B:  SUBWF  5D,W
058C:  BTFSC  03.0
058D:  GOTO   591
058E:  MOVF   5D,W
058F:  MOVWF  77
0590:  GOTO   59D
0591:  CLRF   77
0592:  MOVLW  08
0593:  MOVWF  5F
0594:  RLF    5D,F
0595:  RLF    77,F
0596:  MOVF   5E,W
0597:  SUBWF  77,W
0598:  BTFSC  03.0
0599:  MOVWF  77
059A:  RLF    78,F
059B:  DECFSZ 5F,F
059C:  GOTO   594
059D:  RETURN
*
05FB:  MOVLW  20
05FC:  BTFSS  58.4
05FD:  MOVLW  30
05FE:  MOVWF  59
05FF:  MOVF   57,W
0600:  MOVWF  77
0601:  BTFSS  57.7
0602:  GOTO   60B
0603:  COMF   77,F
0604:  INCF   77,F
0605:  MOVF   77,W
0606:  MOVWF  57
0607:  MOVLW  2D
0608:  MOVWF  59
0609:  BSF    58.7
060A:  BSF    58.0
060B:  MOVF   57,W
060C:  MOVWF  5D
060D:  MOVLW  64
060E:  MOVWF  5E
060F:  CALL   589
0610:  MOVF   77,W
0611:  MOVWF  57
0612:  MOVLW  30
0613:  ADDWF  78,W
0614:  MOVWF  5A
0615:  MOVF   57,W
0616:  MOVWF  5D
0617:  MOVLW  0A
0618:  MOVWF  5E
0619:  CALL   589
061A:  MOVLW  30
061B:  ADDWF  77,W
061C:  MOVWF  5C
061D:  MOVLW  30
061E:  ADDWF  78,W
061F:  MOVWF  5B
0620:  MOVF   59,W
0621:  MOVWF  77
0622:  MOVLW  30
0623:  SUBWF  5A,W
0624:  BTFSC  03.2
0625:  GOTO   62A
0626:  BSF    58.1
0627:  BTFSC  58.7
0628:  BSF    58.2
0629:  GOTO   63E
062A:  MOVF   59,W
062B:  MOVWF  5A
062C:  MOVLW  20
062D:  MOVWF  59
062E:  MOVLW  30
062F:  SUBWF  5B,W
0630:  BTFSC  03.2
0631:  GOTO   636
0632:  BSF    58.0
0633:  BTFSC  58.7
0634:  BSF    58.1
0635:  GOTO   63E
0636:  BTFSS  03.2
0637:  BSF    58.0
0638:  BTFSS  03.2
0639:  GOTO   63E
063A:  MOVF   5A,W
063B:  MOVWF  5B
063C:  MOVLW  20
063D:  MOVWF  5A
063E:  BTFSC  58.2
063F:  GOTO   645
0640:  BTFSC  58.1
0641:  GOTO   648
0642:  BTFSC  58.0
0643:  GOTO   64B
0644:  GOTO   64E
0645:  MOVF   59,W
0646:  MOVWF  5D
0647:  CALL   4C3
0648:  MOVF   5A,W
0649:  MOVWF  5D
064A:  CALL   4C3
064B:  MOVF   5B,W
064C:  MOVWF  5D
064D:  CALL   4C3
064E:  MOVF   5C,W
064F:  MOVWF  5D
0650:  CALL   4C3
0651:  RETURN
0652:  MOVF   0B,W
0653:  MOVWF  56
0654:  BCF    0B.7
0655:  BSF    03.5
0656:  BSF    03.6
0657:  BSF    0C.7
0658:  BSF    0C.0
0659:  NOP
065A:  NOP
065B:  BCF    03.5
065C:  BCF    03.6
065D:  BTFSC  56.7
065E:  BSF    0B.7
065F:  BTFSC  03.0
0660:  GOTO   689
0661:  BSF    03.6
0662:  MOVF   0C,W
0663:  ANDLW  7F
0664:  BCF    03.6
0665:  MOVWF  56
0666:  BSF    03.6
0667:  MOVF   0D,W
0668:  BCF    03.6
0669:  MOVWF  57
066A:  BSF    03.6
066B:  MOVF   0F,W
066C:  BCF    03.6
066D:  MOVWF  58
066E:  MOVF   56,W
066F:  MOVWF  5D
0670:  CALL   4C3
0671:  MOVF   57,W
0672:  BSF    03.6
0673:  MOVWF  0D
0674:  BCF    03.6
0675:  MOVF   58,W
0676:  BSF    03.6
0677:  MOVWF  0F
0678:  BCF    03.6
0679:  MOVF   0B,W
067A:  MOVWF  59
067B:  BCF    0B.7
067C:  BSF    03.5
067D:  BSF    03.6
067E:  BSF    0C.7
067F:  BSF    0C.0
0680:  NOP
0681:  NOP
0682:  BCF    03.5
0683:  BCF    03.6
0684:  BTFSC  59.7
0685:  BSF    0B.7
0686:  DECFSZ 55,F
0687:  GOTO   689
0688:  GOTO   6A8
0689:  BSF    03.6
068A:  RLF    0C,W
068B:  RLF    0E,W
068C:  ANDLW  7F
068D:  BCF    03.6
068E:  MOVWF  56
068F:  BSF    03.6
0690:  MOVF   0D,W
0691:  BCF    03.6
0692:  MOVWF  57
0693:  BSF    03.6
0694:  MOVF   0F,W
0695:  BCF    03.6
0696:  MOVWF  58
0697:  MOVF   56,W
0698:  MOVWF  5D
0699:  CALL   4C3
069A:  MOVF   57,W
069B:  BSF    03.6
069C:  MOVWF  0D
069D:  BCF    03.6
069E:  MOVF   58,W
069F:  BSF    03.6
06A0:  MOVWF  0F
06A1:  INCF   0D,F
06A2:  BTFSC  03.2
06A3:  INCF   0F,F
06A4:  BCF    03.0
06A5:  BCF    03.6
06A6:  DECFSZ 55,F
06A7:  GOTO   652
06A8:  RETURN
*
072C:  MOVF   0B,W
072D:  MOVWF  56
072E:  BCF    0B.7
072F:  BSF    03.5
0730:  BSF    03.6
0731:  BSF    0C.7
0732:  BSF    0C.0
0733:  NOP
0734:  NOP
0735:  BCF    03.5
0736:  BCF    03.6
0737:  BTFSC  56.7
0738:  BSF    0B.7
0739:  BSF    03.6
073A:  MOVF   0C,W
073B:  ANDLW  7F
073C:  BTFSC  03.2
073D:  GOTO   780
073E:  BCF    03.6
073F:  MOVWF  56
0740:  BSF    03.6
0741:  MOVF   0D,W
0742:  BCF    03.6
0743:  MOVWF  57
0744:  BSF    03.6
0745:  MOVF   0F,W
0746:  BCF    03.6
0747:  MOVWF  58
0748:  MOVF   56,W
0749:  MOVWF  5D
074A:  CALL   6ED
074B:  MOVF   57,W
074C:  BSF    03.6
074D:  MOVWF  0D
074E:  BCF    03.6
074F:  MOVF   58,W
0750:  BSF    03.6
0751:  MOVWF  0F
0752:  BCF    03.6
0753:  MOVF   0B,W
0754:  MOVWF  59
0755:  BCF    0B.7
0756:  BSF    03.5
0757:  BSF    03.6
0758:  BSF    0C.7
0759:  BSF    0C.0
075A:  NOP
075B:  NOP
075C:  BCF    03.5
075D:  BCF    03.6
075E:  BTFSC  59.7
075F:  BSF    0B.7
0760:  BSF    03.6
0761:  RLF    0C,W
0762:  RLF    0E,W
0763:  ANDLW  7F
0764:  BTFSC  03.2
0765:  GOTO   780
0766:  BCF    03.6
0767:  MOVWF  56
0768:  BSF    03.6
0769:  MOVF   0D,W
076A:  BCF    03.6
076B:  MOVWF  57
076C:  BSF    03.6
076D:  MOVF   0F,W
076E:  BCF    03.6
076F:  MOVWF  58
0770:  MOVF   56,W
0771:  MOVWF  5D
0772:  CALL   6ED
0773:  MOVF   57,W
0774:  BSF    03.6
0775:  MOVWF  0D
0776:  BCF    03.6
0777:  MOVF   58,W
0778:  BSF    03.6
0779:  MOVWF  0F
077A:  INCF   0D,F
077B:  BTFSC  03.2
077C:  INCF   0F,F
077D:  BCF    03.6
077E:  GOTO   72C
077F:  BSF    03.6
0780:  BCF    03.6
0781:  RETURN
0782:  MOVLW  20
0783:  BTFSS  58.4
0784:  MOVLW  30
0785:  MOVWF  59
0786:  MOVF   57,W
0787:  MOVWF  77
0788:  BTFSS  57.7
0789:  GOTO   792
078A:  COMF   77,F
078B:  INCF   77,F
078C:  MOVF   77,W
078D:  MOVWF  57
078E:  MOVLW  2D
078F:  MOVWF  59
0790:  BSF    58.7
0791:  BSF    58.0
0792:  MOVF   57,W
0793:  MOVWF  5D
0794:  MOVLW  64
0795:  MOVWF  5E
0796:  CALL   589
0797:  MOVF   77,W
0798:  MOVWF  57
0799:  MOVLW  30
079A:  ADDWF  78,W
079B:  MOVWF  5A
079C:  MOVF   57,W
079D:  MOVWF  5D
079E:  MOVLW  0A
079F:  MOVWF  5E
07A0:  CALL   589
07A1:  MOVLW  30
07A2:  ADDWF  77,W
07A3:  MOVWF  5C
07A4:  MOVLW  30
07A5:  ADDWF  78,W
07A6:  MOVWF  5B
07A7:  MOVF   59,W
07A8:  MOVWF  77
07A9:  MOVLW  30
07AA:  SUBWF  5A,W
07AB:  BTFSC  03.2
07AC:  GOTO   7B1
07AD:  BSF    58.1
07AE:  BTFSC  58.7
07AF:  BSF    58.2
07B0:  GOTO   7C5
07B1:  MOVF   59,W
07B2:  MOVWF  5A
07B3:  MOVLW  20
07B4:  MOVWF  59
07B5:  MOVLW  30
07B6:  SUBWF  5B,W
07B7:  BTFSC  03.2
07B8:  GOTO   7BD
07B9:  BSF    58.0
07BA:  BTFSC  58.7
07BB:  BSF    58.1
07BC:  GOTO   7C5
07BD:  BTFSS  03.2
07BE:  BSF    58.0
07BF:  BTFSS  03.2
07C0:  GOTO   7C5
07C1:  MOVF   5A,W
07C2:  MOVWF  5B
07C3:  MOVLW  20
07C4:  MOVWF  5A
07C5:  BTFSC  58.2
07C6:  GOTO   7CC
07C7:  BTFSC  58.1
07C8:  GOTO   7CF
07C9:  BTFSC  58.0
07CA:  GOTO   7D2
07CB:  GOTO   7D5
07CC:  MOVF   59,W
07CD:  MOVWF  5D
07CE:  CALL   6ED
07CF:  MOVF   5A,W
07D0:  MOVWF  5D
07D1:  CALL   6ED
07D2:  MOVF   5B,W
07D3:  MOVWF  5D
07D4:  CALL   6ED
07D5:  MOVF   5C,W
07D6:  MOVWF  5D
07D7:  CALL   6ED
07D8:  RETURN
*
0879:  MOVF   0B,W
087A:  MOVWF  56
087B:  BCF    0B.7
087C:  BSF    03.5
087D:  BSF    03.6
087E:  BSF    0C.7
087F:  BSF    0C.0
0880:  NOP
0881:  NOP
0882:  BCF    03.5
0883:  BCF    03.6
0884:  BTFSC  56.7
0885:  BSF    0B.7
0886:  BTFSC  03.0
0887:  GOTO   0B2
0888:  BSF    03.6
0889:  MOVF   0C,W
088A:  ANDLW  7F
088B:  BCF    03.6
088C:  MOVWF  56
088D:  BSF    03.6
088E:  MOVF   0D,W
088F:  BCF    03.6
0890:  MOVWF  57
0891:  BSF    03.6
0892:  MOVF   0F,W
0893:  BCF    03.6
0894:  MOVWF  58
0895:  MOVF   56,W
0896:  MOVWF  5D
0897:  BCF    0A.3
0898:  CALL   6ED
0899:  BSF    0A.3
089A:  MOVF   57,W
089B:  BSF    03.6
089C:  MOVWF  0D
089D:  BCF    03.6
089E:  MOVF   58,W
089F:  BSF    03.6
08A0:  MOVWF  0F
08A1:  BCF    03.6
08A2:  MOVF   0B,W
08A3:  MOVWF  59
08A4:  BCF    0B.7
08A5:  BSF    03.5
08A6:  BSF    03.6
08A7:  BSF    0C.7
08A8:  BSF    0C.0
08A9:  NOP
08AA:  NOP
08AB:  BCF    03.5
08AC:  BCF    03.6
08AD:  BTFSC  59.7
08AE:  BSF    0B.7
08AF:  DECFSZ 55,F
08B0:  GOTO   0B2
08B1:  GOTO   0D3
08B2:  BSF    03.6
08B3:  RLF    0C,W
08B4:  RLF    0E,W
08B5:  ANDLW  7F
08B6:  BCF    03.6
08B7:  MOVWF  56
08B8:  BSF    03.6
08B9:  MOVF   0D,W
08BA:  BCF    03.6
08BB:  MOVWF  57
08BC:  BSF    03.6
08BD:  MOVF   0F,W
08BE:  BCF    03.6
08BF:  MOVWF  58
08C0:  MOVF   56,W
08C1:  MOVWF  5D
08C2:  BCF    0A.3
08C3:  CALL   6ED
08C4:  BSF    0A.3
08C5:  MOVF   57,W
08C6:  BSF    03.6
08C7:  MOVWF  0D
08C8:  BCF    03.6
08C9:  MOVF   58,W
08CA:  BSF    03.6
08CB:  MOVWF  0F
08CC:  INCF   0D,F
08CD:  BTFSC  03.2
08CE:  INCF   0F,F
08CF:  BCF    03.0
08D0:  BCF    03.6
08D1:  DECFSZ 55,F
08D2:  GOTO   079
08D3:  RETURN
*
0DCF:  BSF    0A.0
0DD0:  BCF    0A.1
0DD1:  BSF    0A.2
0DD2:  ADDWF  02,F
0DD3:  GOTO   213
0DD4:  GOTO   27B
0DD5:  GOTO   28A
0DD6:  GOTO   440
*
1253:  BCF    0A.0
1254:  BSF    0A.1
1255:  BCF    0A.2
1256:  ADDWF  02,F
1257:  GOTO   128
1258:  GOTO   130
1259:  GOTO   136
125A:  GOTO   13C
125B:  BCF    0A.0
125C:  BSF    0A.1
125D:  BCF    0A.2
125E:  ADDWF  02,F
125F:  GOTO   1D3
1260:  GOTO   1DB
1261:  GOTO   1E3
1262:  GOTO   1EA
....................  
.................... #list 
....................  
.................... #device ADC=8 
.................... #FUSES HS 
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
....................  
.................... #use delay(crystal=8000000) 
*
03D5:  MOVLW  54
03D6:  MOVWF  04
03D7:  BCF    03.7
03D8:  MOVF   00,W
03D9:  BTFSC  03.2
03DA:  GOTO   3E8
03DB:  MOVLW  02
03DC:  MOVWF  78
03DD:  CLRF   77
03DE:  DECFSZ 77,F
03DF:  GOTO   3DE
03E0:  DECFSZ 78,F
03E1:  GOTO   3DD
03E2:  MOVLW  97
03E3:  MOVWF  77
03E4:  DECFSZ 77,F
03E5:  GOTO   3E4
03E6:  DECFSZ 00,F
03E7:  GOTO   3DB
03E8:  RETURN
*
07D9:  MOVLW  08
07DA:  SUBWF  5A,F
07DB:  BTFSS  03.0
07DC:  GOTO   7E9
07DD:  MOVLW  5A
07DE:  MOVWF  04
07DF:  BCF    03.7
07E0:  BCF    03.0
07E1:  RRF    00,F
07E2:  MOVF   00,W
07E3:  BTFSC  03.2
07E4:  GOTO   7E9
07E5:  GOTO   7E7
07E6:  NOP
07E7:  DECFSZ 00,F
07E8:  GOTO   7E6
07E9:  RETURN
.................... //#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8) 
....................  
.................... #byte portb=0x06 
.................... #byte trisb=0x86 
.................... #byte ANSEL=0x188 
.................... #byte ANSELH=0x189 
.................... #bit trisb0=trisb.0 
.................... #bit trisb4=trisb.4 
.................... #bit trisb5=trisb.5 
....................  
.................... //#include <lcd.c> 
.................... #include <ds1302.c> 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_B1 
.................... #define RTC_IO   PIN_B3 
.................... #define RTC_RST  PIN_B2 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(unsigned int8 cmd) { 
....................    unsigned int8 i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
035D:  CLRF   5C
035E:  MOVF   5C,W
035F:  SUBLW  07
0360:  BTFSS  03.0
0361:  GOTO   374
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
0362:  BCF    03.0
0363:  RRF    5B,F
0364:  BTFSC  03.0
0365:  GOTO   368
0366:  BCF    06.3
0367:  GOTO   369
0368:  BSF    06.3
0369:  BSF    03.5
036A:  BCF    06.3
....................       output_high(RTC_SCLK); 
036B:  BCF    06.1
036C:  BCF    03.5
036D:  BSF    06.1
....................       output_low(RTC_SCLK); 
036E:  BSF    03.5
036F:  BCF    06.1
0370:  BCF    03.5
0371:  BCF    06.1
0372:  INCF   5C,F
0373:  GOTO   35E
....................    } 
0374:  RETURN
.................... } 
....................  
.................... void write_ds1302(unsigned int8 cmd, unsigned int8 data) { 
....................  
....................    output_high(RTC_RST); 
0375:  BSF    03.5
0376:  BCF    06.2
0377:  BCF    03.5
0378:  BSF    06.2
....................    write_ds1302_byte(cmd); 
0379:  MOVF   59,W
037A:  MOVWF  5B
037B:  CALL   35D
....................    write_ds1302_byte(data); 
037C:  MOVF   5A,W
037D:  MOVWF  5B
037E:  CALL   35D
....................    output_low(RTC_RST); 
037F:  BSF    03.5
0380:  BCF    06.2
0381:  BCF    03.5
0382:  BCF    06.2
0383:  RETURN
.................... } 
....................  
.................... unsigned int8 read_ds1302(unsigned int8 cmd) { 
....................    unsigned int8 i,data; 
....................  
....................    output_high(RTC_RST); 
0384:  BSF    03.5
0385:  BCF    06.2
0386:  BCF    03.5
0387:  BSF    06.2
....................    write_ds1302_byte(cmd); 
0388:  MOVF   56,W
0389:  MOVWF  5B
038A:  CALL   35D
....................     
....................    input(RTC_IO); 
038B:  BSF    03.5
038C:  BSF    06.3
....................    delay_us(1); 
038D:  GOTO   38E
....................           
....................    for(i=0;i<=7;++i) { 
038E:  BCF    03.5
038F:  CLRF   57
0390:  MOVF   57,W
0391:  SUBLW  07
0392:  BTFSS  03.0
0393:  GOTO   3AB
....................       shift_right(&data,1,input(RTC_IO)); 
0394:  BSF    03.5
0395:  BSF    06.3
0396:  BCF    03.5
0397:  BTFSC  06.3
0398:  GOTO   39B
0399:  BCF    03.0
039A:  GOTO   39C
039B:  BSF    03.0
039C:  RRF    58,F
....................       output_high(RTC_SCLK); 
039D:  BSF    03.5
039E:  BCF    06.1
039F:  BCF    03.5
03A0:  BSF    06.1
....................       delay_us(2); 
03A1:  GOTO   3A2
03A2:  GOTO   3A3
....................       output_low(RTC_SCLK); 
03A3:  BSF    03.5
03A4:  BCF    06.1
03A5:  BCF    03.5
03A6:  BCF    06.1
....................       delay_us(2); 
03A7:  GOTO   3A8
03A8:  GOTO   3A9
03A9:  INCF   57,F
03AA:  GOTO   390
....................    } 
....................    output_low(RTC_RST); 
03AB:  BSF    03.5
03AC:  BCF    06.2
03AD:  BCF    03.5
03AE:  BCF    06.2
....................  
....................    return(data); 
03AF:  MOVF   58,W
03B0:  MOVWF  78
03B1:  RETURN
.................... } 
....................  
.................... void rtc_init() { 
....................    unsigned int8 x; 
....................    output_low(RTC_RST); 
03B2:  BSF    03.5
03B3:  BCF    06.2
03B4:  BCF    03.5
03B5:  BCF    06.2
....................    delay_us(2); 
03B6:  GOTO   3B7
03B7:  GOTO   3B8
....................    output_low(RTC_SCLK); 
03B8:  BSF    03.5
03B9:  BCF    06.1
03BA:  BCF    03.5
03BB:  BCF    06.1
....................    write_ds1302(0x8e,0); 
03BC:  MOVLW  8E
03BD:  MOVWF  59
03BE:  CLRF   5A
03BF:  CALL   375
....................    write_ds1302(0x90,0xa4); 
03C0:  MOVLW  90
03C1:  MOVWF  59
03C2:  MOVLW  A4
03C3:  MOVWF  5A
03C4:  CALL   375
....................    x=read_ds1302(0x81); 
03C5:  MOVLW  81
03C6:  MOVWF  56
03C7:  CALL   384
03C8:  MOVF   78,W
03C9:  MOVWF  52
....................    if((x & 0x80)!=0) 
03CA:  MOVF   52,W
03CB:  ANDLW  80
03CC:  BTFSC  03.2
03CD:  GOTO   3D2
....................      write_ds1302(0x80,0); 
03CE:  MOVLW  80
03CF:  MOVWF  59
03D0:  CLRF   5A
03D1:  CALL   375
03D2:  BSF    0A.3
03D3:  BCF    0A.4
03D4:  GOTO   70A (RETURN)
.................... } 
....................  
.................... unsigned int8 get_bcd(unsigned int8 data) 
.................... { 
....................    unsigned int8 nibh; 
....................    unsigned int8 nibl; 
....................  
....................    nibh=data/10; 
*
059E:  MOVF   58,W
059F:  MOVWF  5D
05A0:  MOVLW  0A
05A1:  MOVWF  5E
05A2:  CALL   589
05A3:  MOVF   78,W
05A4:  MOVWF  59
....................    nibl=data-(nibh*10); 
05A5:  MOVF   59,W
05A6:  MOVWF  60
05A7:  MOVLW  0A
05A8:  MOVWF  61
05A9:  CALL   48A
05AA:  MOVF   78,W
05AB:  SUBWF  58,W
05AC:  MOVWF  5A
....................  
....................    return((nibh<<4)|nibl); 
05AD:  SWAPF  59,W
05AE:  MOVWF  77
05AF:  MOVLW  F0
05B0:  ANDWF  77,F
05B1:  MOVF   77,W
05B2:  IORWF  5A,W
05B3:  MOVWF  78
05B4:  RETURN
.................... } 
....................                                           
.................... unsigned int8 rm_bcd(unsigned int8 data) 
.................... {                                                          
....................    unsigned int8 i;                 
....................  
....................    i=data;                      
*
04AF:  MOVF   57,W
04B0:  MOVWF  58
....................    data=(i>>4)*10; 
04B1:  SWAPF  58,W
04B2:  MOVWF  77
04B3:  MOVLW  0F
04B4:  ANDWF  77,F
04B5:  MOVF   77,W
04B6:  MOVWF  5A
04B7:  MOVWF  60
04B8:  MOVLW  0A
04B9:  MOVWF  61
04BA:  CALL   48A
04BB:  MOVF   78,W
04BC:  MOVWF  57
....................    data=data+(i & 0x0F);        
04BD:  MOVF   58,W
04BE:  ANDLW  0F
04BF:  ADDWF  57,F
....................  
....................    return data; 
04C0:  MOVF   57,W
04C1:  MOVWF  78
04C2:  RETURN
.................... } 
....................  
.................... void rtc_set_datetime(unsigned int8 day, unsigned int8 mth, unsigned int8 year, unsigned int8 dow, unsigned int8 hr, unsigned int8 min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
*
05B5:  MOVF   52,W
05B6:  MOVWF  58
05B7:  CALL   59E
05B8:  MOVF   78,W
05B9:  MOVWF  58
05BA:  MOVLW  86
05BB:  MOVWF  59
05BC:  MOVF   78,W
05BD:  MOVWF  5A
05BE:  CALL   375
....................    write_ds1302(0x88,get_bcd(mth)); 
05BF:  MOVF   53,W
05C0:  MOVWF  58
05C1:  CALL   59E
05C2:  MOVF   78,W
05C3:  MOVWF  58
05C4:  MOVLW  88
05C5:  MOVWF  59
05C6:  MOVF   78,W
05C7:  MOVWF  5A
05C8:  CALL   375
....................    write_ds1302(0x8c,get_bcd(year)); 
05C9:  MOVF   54,W
05CA:  MOVWF  58
05CB:  CALL   59E
05CC:  MOVF   78,W
05CD:  MOVWF  58
05CE:  MOVLW  8C
05CF:  MOVWF  59
05D0:  MOVF   78,W
05D1:  MOVWF  5A
05D2:  CALL   375
....................    write_ds1302(0x8a,get_bcd(dow)); 
05D3:  MOVF   55,W
05D4:  MOVWF  58
05D5:  CALL   59E
05D6:  MOVF   78,W
05D7:  MOVWF  58
05D8:  MOVLW  8A
05D9:  MOVWF  59
05DA:  MOVF   78,W
05DB:  MOVWF  5A
05DC:  CALL   375
....................    write_ds1302(0x84,get_bcd(hr)); 
05DD:  MOVF   56,W
05DE:  MOVWF  58
05DF:  CALL   59E
05E0:  MOVF   78,W
05E1:  MOVWF  58
05E2:  MOVLW  84
05E3:  MOVWF  59
05E4:  MOVF   78,W
05E5:  MOVWF  5A
05E6:  CALL   375
....................    write_ds1302(0x82,get_bcd(min)); 
05E7:  MOVF   57,W
05E8:  MOVWF  58
05E9:  CALL   59E
05EA:  MOVF   78,W
05EB:  MOVWF  58
05EC:  MOVLW  82
05ED:  MOVWF  59
05EE:  MOVF   78,W
05EF:  MOVWF  5A
05F0:  CALL   375
....................    write_ds1302(0x80,get_bcd(0)); 
05F1:  CLRF   58
05F2:  CALL   59E
05F3:  MOVF   78,W
05F4:  MOVWF  58
05F5:  MOVLW  80
05F6:  MOVWF  59
05F7:  MOVF   78,W
05F8:  MOVWF  5A
05F9:  CALL   375
05FA:  RETURN
.................... }                                       
....................  
.................... void rtc_get_date(unsigned int8 &day, unsigned int8 &mth, unsigned int8 &year, unsigned int8 &dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
0F38:  MOVLW  87
0F39:  MOVWF  56
0F3A:  BCF    0A.3
0F3B:  CALL   384
0F3C:  BSF    0A.3
0F3D:  MOVF   78,W
0F3E:  MOVWF  52
0F3F:  MOVWF  57
0F40:  BCF    0A.3
0F41:  CALL   4AF
0F42:  BSF    0A.3
0F43:  MOVF   78,W
0F44:  MOVWF  40
....................    mth = rm_bcd(read_ds1302(0x89)); 
0F45:  MOVLW  89
0F46:  MOVWF  56
0F47:  BCF    0A.3
0F48:  CALL   384
0F49:  BSF    0A.3
0F4A:  MOVF   78,W
0F4B:  MOVWF  52
0F4C:  MOVWF  57
0F4D:  BCF    0A.3
0F4E:  CALL   4AF
0F4F:  BSF    0A.3
0F50:  MOVF   78,W
0F51:  MOVWF  41
....................    year = rm_bcd(read_ds1302(0x8d)); 
0F52:  MOVLW  8D
0F53:  MOVWF  56
0F54:  BCF    0A.3
0F55:  CALL   384
0F56:  BSF    0A.3
0F57:  MOVF   78,W
0F58:  MOVWF  52
0F59:  MOVWF  57
0F5A:  BCF    0A.3
0F5B:  CALL   4AF
0F5C:  BSF    0A.3
0F5D:  MOVF   78,W
0F5E:  MOVWF  42
....................    dow = rm_bcd(read_ds1302(0x8b)); 
0F5F:  MOVLW  8B
0F60:  MOVWF  56
0F61:  BCF    0A.3
0F62:  CALL   384
0F63:  BSF    0A.3
0F64:  MOVF   78,W
0F65:  MOVWF  52
0F66:  MOVWF  57
0F67:  BCF    0A.3
0F68:  CALL   4AF
0F69:  BSF    0A.3
0F6A:  MOVF   78,W
0F6B:  MOVWF  43
.................... } 
....................  
.................... void rtc_get_time(unsigned int8 &hr, unsigned int8 &min, unsigned int8 &sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
*
0F11:  MOVLW  85
0F12:  MOVWF  56
0F13:  BCF    0A.3
0F14:  CALL   384
0F15:  BSF    0A.3
0F16:  MOVF   78,W
0F17:  MOVWF  52
0F18:  MOVWF  57
0F19:  BCF    0A.3
0F1A:  CALL   4AF
0F1B:  BSF    0A.3
0F1C:  MOVF   78,W
0F1D:  MOVWF  37
....................    min = rm_bcd(read_ds1302(0x83)); 
0F1E:  MOVLW  83
0F1F:  MOVWF  56
0F20:  BCF    0A.3
0F21:  CALL   384
0F22:  BSF    0A.3
0F23:  MOVF   78,W
0F24:  MOVWF  52
0F25:  MOVWF  57
0F26:  BCF    0A.3
0F27:  CALL   4AF
0F28:  BSF    0A.3
0F29:  MOVF   78,W
0F2A:  MOVWF  38
....................    sec = rm_bcd(read_ds1302(0x81)); 
0F2B:  MOVLW  81
0F2C:  MOVWF  56
0F2D:  BCF    0A.3
0F2E:  CALL   384
0F2F:  BSF    0A.3
0F30:  MOVF   78,W
0F31:  MOVWF  52
0F32:  MOVWF  57
0F33:  BCF    0A.3
0F34:  CALL   4AF
0F35:  BSF    0A.3
0F36:  MOVF   78,W
0F37:  MOVWF  39
.................... } 
....................  
.................... void rtc_write_nvr(unsigned int8 address, unsigned int8 data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... unsigned int8 rtc_read_nvr(unsigned int8 address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include <ds18b20.c> 
.................... #ifndef DS18B20_C 
.................... #define DS18B20_C 
.................... #include "1_day.c" 
.................... #ifndef ONE_WIRE_C 
.................... #define ONE_WIRE_C 
....................  
.................... /* 
....................  * One wire (1-wire) driver for CCS C compiler. Suitable for use with devices 
....................  * such as the DS18B20 1-wire digital temperature sensor. 
....................  */ 
.................... #define ONE_WIRE_PIN PIN_D1 
....................  
.................... /* 
....................  * onewire_reset() 
....................  * Description: Initiates the one wire bus. 
....................  */ 
.................... // OK if just using a single permanently connected device 
.................... void onewire_reset() { 
....................     output_low(ONE_WIRE_PIN);       // pull the bus low for reset 
*
0DD7:  BSF    03.5
0DD8:  BCF    08.1
0DD9:  BCF    03.5
0DDA:  BCF    08.1
....................     delay_us(500); 
0DDB:  MOVLW  02
0DDC:  MOVWF  59
0DDD:  MOVLW  F8
0DDE:  MOVWF  5A
0DDF:  BCF    0A.3
0DE0:  CALL   7D9
0DE1:  BSF    0A.3
0DE2:  DECFSZ 59,F
0DE3:  GOTO   5DD
....................     output_float(ONE_WIRE_PIN);     // float the bus high 
0DE4:  BSF    03.5
0DE5:  BSF    08.1
....................     delay_us(500);                  // wait-out remaining initialisation window 
0DE6:  MOVLW  02
0DE7:  BCF    03.5
0DE8:  MOVWF  59
0DE9:  MOVLW  F8
0DEA:  MOVWF  5A
0DEB:  BCF    0A.3
0DEC:  CALL   7D9
0DED:  BSF    0A.3
0DEE:  DECFSZ 59,F
0DEF:  GOTO   5E9
....................     output_float(ONE_WIRE_PIN); 
0DF0:  BSF    03.5
0DF1:  BSF    08.1
0DF2:  BCF    03.5
0DF3:  RETURN
.................... } 
....................  
....................  
.................... /* 
....................  * onewire_write(int8 data) 
....................  * Arguments: a byte of data. 
....................  * Description: writes a byte of data to the device. 
....................  */ 
.................... void onewire_write(int8 data) { 
....................     int8 count; 
....................  
....................     for(count = 0; count < 8; ++count) { 
0DF4:  CLRF   5A
0DF5:  MOVF   5A,W
0DF6:  SUBLW  07
0DF7:  BTFSS  03.0
0DF8:  GOTO   613
....................         output_low(ONE_WIRE_PIN); 
0DF9:  BSF    03.5
0DFA:  BCF    08.1
0DFB:  BCF    03.5
0DFC:  BCF    08.1
....................         delay_us(2);                // pull 1-wire low to initiate write time-slot. 
0DFD:  GOTO   5FE
0DFE:  GOTO   5FF
....................         output_bit(ONE_WIRE_PIN, shift_right(&data, 1, 0)); // set output bit on 1-wire 
0DFF:  BCF    03.0
0E00:  RRF    59,F
0E01:  BTFSC  03.0
0E02:  GOTO   605
0E03:  BCF    08.1
0E04:  GOTO   606
0E05:  BSF    08.1
0E06:  BSF    03.5
0E07:  BCF    08.1
....................         delay_us(60);               // wait until end of write slot. 
0E08:  MOVLW  27
0E09:  MOVWF  77
0E0A:  DECFSZ 77,F
0E0B:  GOTO   60A
0E0C:  GOTO   60D
....................         output_float(ONE_WIRE_PIN); // set 1-wire high again, 
0E0D:  BSF    08.1
....................         delay_us(2);                // for more than 1us minimum. 
0E0E:  GOTO   60F
0E0F:  GOTO   610
0E10:  BCF    03.5
0E11:  INCF   5A,F
0E12:  GOTO   5F5
....................     } 
0E13:  RETURN
.................... } 
....................  
.................... /* 
....................  * onewire_read() 
....................  * Description: reads and returns a byte of data from the device. 
....................  */ 
.................... int onewire_read() { 
....................     int count, data; 
....................  
....................     for(count = 0; count < 8; ++count) { 
0E14:  CLRF   59
0E15:  MOVF   59,W
0E16:  SUBLW  07
0E17:  BTFSS  03.0
0E18:  GOTO   636
....................         output_low(ONE_WIRE_PIN); 
0E19:  BSF    03.5
0E1A:  BCF    08.1
0E1B:  BCF    03.5
0E1C:  BCF    08.1
....................         delay_us(2);                // pull 1-wire low to initiate read time-slot. 
0E1D:  GOTO   61E
0E1E:  GOTO   61F
....................         output_float(ONE_WIRE_PIN); // now let 1-wire float high, 
0E1F:  BSF    03.5
0E20:  BSF    08.1
....................         delay_us(8);                // let device state stabilise, 
0E21:  MOVLW  04
0E22:  MOVWF  77
0E23:  DECFSZ 77,F
0E24:  GOTO   623
0E25:  GOTO   626
0E26:  NOP
....................         shift_right(&data, 1, input(ONE_WIRE_PIN)); // and load result. 
0E27:  BSF    08.1
0E28:  BCF    03.5
0E29:  BTFSC  08.1
0E2A:  GOTO   62D
0E2B:  BCF    03.0
0E2C:  GOTO   62E
0E2D:  BSF    03.0
0E2E:  RRF    5A,F
....................         delay_us(120);              // wait until end of read slot. 
0E2F:  MOVLW  4F
0E30:  MOVWF  77
0E31:  DECFSZ 77,F
0E32:  GOTO   631
0E33:  GOTO   634
0E34:  INCF   59,F
0E35:  GOTO   615
....................     } 
....................     return data; 
0E36:  MOVF   5A,W
0E37:  MOVWF  78
0E38:  RETURN
.................... }  
....................  
.................... #endif /*ONE_WIRE_C*/ 
....................  
.................... #include <display.c> 
.................... #ifndef DISPLAY_C 
.................... #define DISPLAY_C 
....................  
.................... #define MODE PIN_B0 
.................... #define EDIT PIN_D0 
.................... #define INC PIN_D2 
.................... #define DEC PIN_D3 
.................... #define lcd_sclk  PIN_A0  
.................... #define lcd_sda   PIN_A1               
.................... #define lcd_dc    PIN_A2                      
.................... #define lcd_cs    PIN_A3                                                                             
.................... #define lcd_res   PIN_A5                                                                                       
....................                                                                                                       
.................... #include "5110lib\3310(modified).c" 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... /* 
....................                      LPH7779-LCD(Nokia 3310) library 
....................                      LPH7366-LCD(Nokia 5110) library 
.................... */ 
.................... //////////////////////////////////////////////////////////////////////////////// 
....................  
.................... char CONST TABLE1 [240] = {  // ASCII table for NOKIA LCD: 96 rows * 5 bytes= 480 bytes 
....................                   0x00,0x00,0x00,0x00,0x00,   // 20 space 
....................                   0x00,0x00,0x5f,0x00,0x00,   // 21 ! 
....................                   0x00,0x07,0x00,0x07,0x00,   // 22 " 
....................                   0x14,0x7f,0x14,0x7f,0x14,   // 23 # 
....................                   0x24,0x2a,0x7f,0x2a,0x12,   // 24 $ 
....................                   0x23,0x13,0x08,0x64,0x62,   // 25 % 
....................                   0x36,0x49,0x55,0x22,0x50,   // 26 & 
....................                   0x00,0x05,0x03,0x00,0x00,   // 27 ' 
....................                   0x00,0x1c,0x22,0x41,0x00,   // 28 ( 
....................                   0x00,0x41,0x22,0x1c,0x00,   // 29 ) 
....................                   0x14,0x08,0x3e,0x08,0x14,   // 2a * 
....................                   0x08,0x08,0x3e,0x08,0x08,   // 2b + 
....................                   0x00,0x50,0x30,0x00,0x00,   // 2c , 
....................                   0x08,0x08,0x08,0x08,0x08,   // 2d - 
....................                   0x00,0x60,0x60,0x00,0x00,   // 2e . 
....................                   0x20,0x10,0x08,0x04,0x02,   // 2f / 
....................                   0x3e,0x51,0x49,0x45,0x3e,   // 30 0 
....................                   0x00,0x42,0x7f,0x40,0x00,   // 31 1 
....................                   0x42,0x61,0x51,0x49,0x46,   // 32 2 
....................                   0x21,0x41,0x45,0x4b,0x31,   // 33 3 
....................                   0x18,0x14,0x12,0x7f,0x10,   // 34 4 
....................                   0x27,0x45,0x45,0x45,0x39,   // 35 5 
....................                   0x3c,0x4a,0x49,0x49,0x30,   // 36 6 
....................                   0x01,0x71,0x09,0x05,0x03,   // 37 7 
....................                   0x36,0x49,0x49,0x49,0x36,   // 38 8 
....................                   0x06,0x49,0x49,0x29,0x1e,   // 39 9 
....................                   0x00,0x36,0x36,0x00,0x00,   // 3a : 
....................                   0x00,0x56,0x36,0x00,0x00,   // 3b ; 
....................                   0x08,0x14,0x22,0x41,0x00,   // 3c < 
....................                   0x14,0x14,0x14,0x14,0x14,   // 3d = 
....................                   0x00,0x41,0x22,0x14,0x08,   // 3e > 
....................                   0x02,0x01,0x51,0x09,0x06,   // 3f ? 
....................                   0x32,0x49,0x79,0x41,0x3e,   // 40 @ 
....................                   0x7e,0x11,0x11,0x11,0x7e,   // 41 A 
....................                   0x7f,0x49,0x49,0x49,0x36,   // 42 B 
....................                   0x3e,0x41,0x41,0x41,0x22,   // 43 C 
....................                   0x7f,0x41,0x41,0x22,0x1c,   // 44 D 
....................                   0x7f,0x49,0x49,0x49,0x41,   // 45 E 
....................                   0x7f,0x09,0x09,0x09,0x01,   // 46 F 
....................                   0x3e,0x41,0x49,0x49,0x7a,   // 47 G 
....................                   0x7f,0x08,0x08,0x08,0x7f,   // 48 H 
....................                   0x00,0x41,0x7f,0x41,0x00,   // 49 I 
....................                   0x20,0x40,0x41,0x3f,0x01,   // 4a J 
....................                   0x7f,0x08,0x14,0x22,0x41,   // 4b K 
....................                   0x7f,0x40,0x40,0x40,0x40,   // 4c L 
....................                   0x7f,0x02,0x0c,0x02,0x7f,   // 4d M 
....................                   0x7f,0x04,0x08,0x10,0x7f,   // 4e N 
....................                   0x3e,0x41,0x41,0x41,0x3e};   // 4f O 
....................  
.................... char CONST TABLE2 [240] = { 
....................                   0x7f,0x09,0x09,0x09,0x06,   // 50 P 
....................                   0x3e,0x41,0x51,0x21,0x5e,   // 51 Q 
....................                   0x7f,0x09,0x19,0x29,0x46,   // 52 R 
....................                   0x46,0x49,0x49,0x49,0x31,   // 53 S 
....................                   0x01,0x01,0x7f,0x01,0x01,   // 54 T 
....................                   0x3f,0x40,0x40,0x40,0x3f,   // 55 U 
....................                   0x1f,0x20,0x40,0x20,0x1f,   // 56 V 
....................                   0x3f,0x40,0x38,0x40,0x3f,   // 57 W 
....................                   0x63,0x14,0x08,0x14,0x63,   // 58 X 
....................                   0x07,0x08,0x70,0x08,0x07,   // 59 Y 
....................                   0x61,0x51,0x49,0x45,0x43,   // 5a Z 
....................                   0x00,0x7f,0x41,0x41,0x00,   // 5b [ 
....................                   0x02,0x04,0x08,0x10,0x20,   // 5c \ 
....................                   0x00,0x41,0x41,0x7f,0x00,   // 5d  
....................                   0x04,0x02,0x01,0x02,0x04,   // 5e ^ 
....................                   0x40,0x40,0x40,0x40,0x40,   // 5f _ 
....................                   0x00,0x01,0x02,0x04,0x00,   // 60 ` 
....................                   0x20,0x54,0x54,0x54,0x78,   // 61 a 
....................                   0x7f,0x48,0x44,0x44,0x38,   // 62 b 
....................                   0x38,0x44,0x44,0x44,0x20,   // 63 c 
....................                   0x38,0x44,0x44,0x48,0x7f,   // 64 d 
....................                   0x38,0x54,0x54,0x54,0x18,   // 65 e 
....................                   0x08,0x7e,0x09,0x01,0x02,   // 66 f 
....................                   0x0c,0x52,0x52,0x52,0x3e,   // 67 g 
....................                   0x7f,0x08,0x04,0x04,0x78,   // 68 h 
....................                   0x00,0x44,0x7d,0x40,0x00,   // 69 i 
....................                   0x20,0x40,0x44,0x3d,0x00,   // 6a j 
....................                   0x7f,0x10,0x28,0x44,0x00,   // 6b k 
....................                   0x00,0x41,0x7f,0x40,0x00,   // 6c l 
....................                   0x7c,0x04,0x18,0x04,0x78,   // 6d m 
....................                   0x7c,0x08,0x04,0x04,0x78,   // 6e n 
....................                   0x38,0x44,0x44,0x44,0x38,   // 6f o 
....................                   0x7c,0x14,0x14,0x14,0x08,   // 70 p 
....................                   0x08,0x14,0x14,0x18,0x7c,   // 71 q 
....................                   0x7c,0x08,0x04,0x04,0x08,   // 72 r 
....................                   0x48,0x54,0x54,0x54,0x20,   // 73 s 
....................                   0x04,0x3f,0x44,0x40,0x20,   // 74 t 
....................                   0x3c,0x40,0x40,0x20,0x7c,   // 75 u 
....................                   0x1c,0x20,0x40,0x20,0x1c,   // 76 v 
....................                   0x3c,0x40,0x30,0x40,0x3c,   // 77 w 
....................                   0x44,0x28,0x10,0x28,0x44,   // 78 x 
....................                   0x0c,0x50,0x50,0x50,0x3c,   // 79 y 
....................                   0x44,0x64,0x54,0x4c,0x44,   // 7a z 
....................                   0x00,0x08,0x36,0x41,0x00,   // 7b { 
....................                   0x00,0x00,0x7f,0x00,0x00,   // 7c | 
....................                   0x00,0x41,0x36,0x08,0x00,   // 7d } 
....................                   0x00,0x00,0x07,0x05,0x07, 
....................                   //0x10,0x08,0x08,0x10,0x08,   // 7e ~ 
....................                   0x78,0x46,0x41,0x46,0x78};  // 7f  
....................  
....................          // 7e,43,40,43,7e -->  
....................          // 7e,43,42,43,7e -->  
....................          // 1e,21,21,71,21 -->  
....................          // 3c,42,53,53,72 -->  
....................  
.................... //function prototypes 
.................... void    nokia_init(); 
.................... void    nokia_write_command(char bytefornokia_command); 
.................... void    nokia_write_data(char bytefornokia_data); 
.................... void    nokia_write_dorc(char bytefornokia); 
.................... void    nokia_gotoxy(char xnokia, char ynokia); 
.................... void    nokia_contrast (byte contrast); 
.................... void    nokia_printchar(char cvar); 
.................... void    nokia_printchar_inverted(char cvar); 
.................... void    nokia_clean_ddram(); 
.................... void    table_to_nokialcd(); 
.................... void    table_to_nokialcd_inverted(); 
.................... void    LcdPixel (char x, char y); 
....................  
.................... char char_row,charsel,charpos,chardata; 
.................... int16 ddram; 
....................  
.................... void nokia_init() { 
....................    output_high(lcd_dc);            // bytes are stored in the display data ram, address counter, incremented automatically 
*
044F:  BSF    03.5
0450:  BCF    05.2
0451:  BCF    03.5
0452:  BSF    05.2
....................    output_high(lcd_cs);            // chip disabled 
0453:  BSF    03.5
0454:  BCF    05.3
0455:  BCF    03.5
0456:  BSF    05.3
....................    delay_us(200); 
0457:  MOVLW  84
0458:  MOVWF  77
0459:  DECFSZ 77,F
045A:  GOTO   459
045B:  GOTO   45C
045C:  NOP
....................  
....................    output_low(lcd_res); 
045D:  BSF    03.5
045E:  BCF    05.5
045F:  BCF    03.5
0460:  BCF    05.5
....................    delay_ms(50); 
0461:  MOVLW  32
0462:  MOVWF  54
0463:  CALL   3D5
....................    output_high(lcd_res); 
0464:  BSF    03.5
0465:  BCF    05.5
0466:  BCF    03.5
0467:  BSF    05.5
....................  
....................    nokia_write_command(0x21); // set extins extended instruction set 
0468:  MOVLW  21
0469:  MOVWF  5B
046A:  CALL   405
....................    nokia_write_command(0xc8); // Vop  v1: 0xc8 (for 3V), v2: 0xa0 (for 3V) 
046B:  MOVLW  C8
046C:  MOVWF  5B
046D:  CALL   405
....................    nokia_write_command(0x12); // bias (contrast) 
046E:  MOVLW  12
046F:  MOVWF  5B
0470:  CALL   405
....................    nokia_write_command(0x20); // horizontal mode from left to right, X axe are incremented automatically, 
0471:  MOVLW  20
0472:  MOVWF  5B
0473:  CALL   405
....................                               // 0x22 for vertical addressing, back on normal instruction set too 
....................    nokia_write_command(0x09); // all on 
0474:  MOVLW  09
0475:  MOVWF  5B
0476:  CALL   405
....................  
....................    delay_ms(50); 
0477:  MOVLW  32
0478:  MOVWF  54
0479:  CALL   3D5
....................  
....................    nokia_clean_ddram();       // reset DDRAM, otherwise the lcd is blurred with random pixels 
047A:  CALL   43A
....................  
....................    delay_ms(10); 
047B:  MOVLW  0A
047C:  MOVWF  54
047D:  CALL   3D5
....................  
....................    nokia_write_command(0x08); // mod control blank change (all off) 
047E:  MOVLW  08
047F:  MOVWF  5B
0480:  CALL   405
....................    delay_ms(10); 
0481:  MOVLW  0A
0482:  MOVWF  54
0483:  CALL   3D5
....................  
....................    nokia_write_command(0x0c); // mod control normal change 
0484:  MOVLW  0C
0485:  MOVWF  5B
0486:  CALL   405
0487:  BSF    0A.3
0488:  BCF    0A.4
0489:  GOTO   70D (RETURN)
.................... } 
....................  
.................... void nokia_clean_ddram() { 
....................    nokia_gotoxy(0,0);         // 84*6=504      clear LCD 
*
043A:  CLRF   58
043B:  CLRF   59
043C:  CALL   419
....................    for (ddram=504; ddram>0; ddram--) 
043D:  MOVLW  01
043E:  MOVWF  25
043F:  MOVLW  F8
0440:  MOVWF  24
0441:  MOVF   24,F
0442:  BTFSS  03.2
0443:  GOTO   447
0444:  MOVF   25,F
0445:  BTFSC  03.2
0446:  GOTO   44E
....................       nokia_write_data(0x00); 
0447:  CLRF   5F
0448:  CALL   426
0449:  MOVF   24,W
044A:  BTFSC  03.2
044B:  DECF   25,F
044C:  DECF   24,F
044D:  GOTO   441
044E:  RETURN
.................... } 
....................  
.................... void nokia_write_command(char bytefornokia_command) 
.................... { 
....................    output_low(lcd_dc);   // byte is a command it is read with the eight SCLK pulse 
*
0405:  BSF    03.5
0406:  BCF    05.2
0407:  BCF    03.5
0408:  BCF    05.2
....................    output_low(lcd_cs);   // chip enabled 
0409:  BSF    03.5
040A:  BCF    05.3
040B:  BCF    03.5
040C:  BCF    05.3
....................    delay_us(2); 
040D:  GOTO   40E
040E:  GOTO   40F
....................    nokia_write_dorc(bytefornokia_command); 
040F:  MOVF   5B,W
0410:  MOVWF  60
0411:  CALL   3E9
....................    output_high(lcd_cs);   // chip disabled 
0412:  BSF    03.5
0413:  BCF    05.3
0414:  BCF    03.5
0415:  BSF    05.3
....................    delay_us(2); 
0416:  GOTO   417
0417:  GOTO   418
0418:  RETURN
.................... } 
....................  
.................... void nokia_write_data(char bytefornokia_data) 
.................... { 
....................    output_high(lcd_dc); 
*
0426:  BSF    03.5
0427:  BCF    05.2
0428:  BCF    03.5
0429:  BSF    05.2
....................    output_low(lcd_cs);   // chip enabled 
042A:  BSF    03.5
042B:  BCF    05.3
042C:  BCF    03.5
042D:  BCF    05.3
....................    delay_us(2); 
042E:  GOTO   42F
042F:  GOTO   430
....................    nokia_write_dorc(bytefornokia_data); 
0430:  MOVF   5F,W
0431:  MOVWF  60
0432:  CALL   3E9
....................    output_high(lcd_cs);   // chip disabled 
0433:  BSF    03.5
0434:  BCF    05.3
0435:  BCF    03.5
0436:  BSF    05.3
....................    delay_us(2); 
0437:  GOTO   438
0438:  GOTO   439
0439:  RETURN
.................... } 
....................  
.................... void nokia_write_dorc(char bytefornokia) {      // serial write data or command subroutine 
....................    char caa; 
....................    for (caa=8;caa>0;caa--) 
*
03E9:  MOVLW  08
03EA:  MOVWF  61
03EB:  MOVF   61,F
03EC:  BTFSC  03.2
03ED:  GOTO   404
....................    { 
....................       output_low(lcd_sclk); 
03EE:  BSF    03.5
03EF:  BCF    05.0
03F0:  BCF    03.5
03F1:  BCF    05.0
....................       delay_us(2); 
03F2:  GOTO   3F3
03F3:  GOTO   3F4
....................       output_bit(lcd_sda,(bytefornokia&0x80)); 
03F4:  BTFSC  60.7
03F5:  GOTO   3F8
03F6:  BCF    05.1
03F7:  GOTO   3F9
03F8:  BSF    05.1
03F9:  BSF    03.5
03FA:  BCF    05.1
....................       output_high(lcd_sclk); 
03FB:  BCF    05.0
03FC:  BCF    03.5
03FD:  BSF    05.0
....................       delay_us(2); 
03FE:  GOTO   3FF
03FF:  GOTO   400
....................       bytefornokia = bytefornokia << 1; 
0400:  BCF    03.0
0401:  RLF    60,F
0402:  DECF   61,F
0403:  GOTO   3EB
....................    } 
0404:  RETURN
.................... } 
....................  
.................... void nokia_gotoxy(char xnokia, char ynokia) {   // Nokia LCD 3310 Position cursor 
....................    nokia_write_command(0x40|(ynokia&0x07));     // Y axe initialisation: 0100 0yyy 
*
0419:  MOVF   59,W
041A:  ANDLW  07
041B:  IORLW  40
041C:  MOVWF  5A
041D:  MOVWF  5B
041E:  CALL   405
....................    nokia_write_command(0x80|(xnokia&0x7f));     // X axe initialisation: 1xxx xxxx 
041F:  MOVF   58,W
0420:  ANDLW  7F
0421:  IORLW  80
0422:  MOVWF  5A
0423:  MOVWF  5B
0424:  CALL   405
0425:  RETURN
.................... } 
....................  
.................... void nokia_contrast (char contrast) { 
....................     nokia_write_command(0x21);                  // LCD Extended Commands. 
....................     nokia_write_command(0x80 | contrast);       // Set LCD Vop (Contrast). 
....................     nokia_write_command(0x20);                  // LCD Standard Commands, horizontal addressing mode. 
.................... } 
....................  
.................... void nokia_printchar(char cvar) {               // Write 1 character to LCD 
....................    charsel=cvar; 
*
04C3:  MOVF   5D,W
04C4:  MOVWF  21
....................    table_to_nokialcd(); 
*
04FD:  RETURN
.................... } 
.................... void nokia_printchar_inverted(char cvar) {               // Write 1 character to LCD 
....................    charsel=cvar; 
*
06ED:  MOVF   5D,W
06EE:  MOVWF  21
....................    table_to_nokialcd_inverted(); 
*
072B:  RETURN
.................... } 
.................... void table_to_nokialcd() {                      // extract ascii from tables & write to LCD 
....................    if (charsel<0x20) return; 
*
04C5:  MOVF   21,W
04C6:  SUBLW  1F
04C7:  BTFSC  03.0
04C8:  GOTO   4FD
....................    if (charsel>0x7f) return; 
04C9:  MOVF   21,W
04CA:  SUBLW  7F
04CB:  BTFSS  03.0
04CC:  GOTO   4FD
....................  
....................    for (char_row=0;char_row<5;char_row++) 
04CD:  CLRF   20
04CE:  MOVF   20,W
04CF:  SUBLW  04
04D0:  BTFSS  03.0
04D1:  GOTO   4FB
....................       { 
....................          if (charsel<0x50){charpos=(((charsel&0xff)-0x20)*5);chardata=TABLE1[(charpos+char_row)];}   // use TABLE1 
04D2:  MOVF   21,W
04D3:  SUBLW  4F
04D4:  BTFSS  03.0
04D5:  GOTO   4E4
04D6:  MOVF   21,W
04D7:  ADDLW  E0
04D8:  MOVWF  5F
04D9:  MOVWF  60
04DA:  MOVLW  05
04DB:  MOVWF  61
04DC:  CALL   48A
04DD:  MOVF   78,W
04DE:  MOVWF  22
04DF:  MOVF   20,W
04E0:  ADDWF  22,W
04E1:  CALL   004
04E2:  MOVWF  78
04E3:  MOVWF  23
....................          if (charsel>0x4f){charpos=(((charsel&0xff)-0x50)*5);chardata=TABLE2[(charpos+char_row)];}   // use TABLE2 
04E4:  MOVF   21,W
04E5:  SUBLW  4F
04E6:  BTFSC  03.0
04E7:  GOTO   4F6
04E8:  MOVF   21,W
04E9:  ADDLW  B0
04EA:  MOVWF  5F
04EB:  MOVWF  60
04EC:  MOVLW  05
04ED:  MOVWF  61
04EE:  CALL   48A
04EF:  MOVF   78,W
04F0:  MOVWF  22
04F1:  MOVF   20,W
04F2:  ADDWF  22,W
04F3:  CALL   0F8
04F4:  MOVWF  78
04F5:  MOVWF  23
....................         
....................          nokia_write_data(chardata);  // send data to nokia 
04F6:  MOVF   23,W
04F7:  MOVWF  5F
04F8:  CALL   426
04F9:  INCF   20,F
04FA:  GOTO   4CE
....................       } 
....................          nokia_write_data(0x00);      // 1 byte (always blank) 
04FB:  CLRF   5F
04FC:  CALL   426
.................... } 
.................... void table_to_nokialcd_inverted() {                      // extract ascii from tables & write to LCD 
....................    if (charsel<0x20) return; 
*
06EF:  MOVF   21,W
06F0:  SUBLW  1F
06F1:  BTFSC  03.0
06F2:  GOTO   72B
....................    if (charsel>0x7f) return; 
06F3:  MOVF   21,W
06F4:  SUBLW  7F
06F5:  BTFSS  03.0
06F6:  GOTO   72B
....................  
....................    for (char_row=0;char_row<5;char_row++) 
06F7:  CLRF   20
06F8:  MOVF   20,W
06F9:  SUBLW  04
06FA:  BTFSS  03.0
06FB:  GOTO   728
....................       { 
....................          if (charsel<0x50){charpos=(((charsel&0xff)-0x20)*5);chardata=TABLE1[(charpos+char_row)];}   // use TABLE1 
06FC:  MOVF   21,W
06FD:  SUBLW  4F
06FE:  BTFSS  03.0
06FF:  GOTO   70E
0700:  MOVF   21,W
0701:  ADDLW  E0
0702:  MOVWF  5F
0703:  MOVWF  60
0704:  MOVLW  05
0705:  MOVWF  61
0706:  CALL   48A
0707:  MOVF   78,W
0708:  MOVWF  22
0709:  MOVF   20,W
070A:  ADDWF  22,W
070B:  CALL   004
070C:  MOVWF  78
070D:  MOVWF  23
....................          if (charsel>0x4f){charpos=(((charsel&0xff)-0x50)*5);chardata=TABLE2[(charpos+char_row)];}   // use TABLE2 
070E:  MOVF   21,W
070F:  SUBLW  4F
0710:  BTFSC  03.0
0711:  GOTO   720
0712:  MOVF   21,W
0713:  ADDLW  B0
0714:  MOVWF  5F
0715:  MOVWF  60
0716:  MOVLW  05
0717:  MOVWF  61
0718:  CALL   48A
0719:  MOVF   78,W
071A:  MOVWF  22
071B:  MOVF   20,W
071C:  ADDWF  22,W
071D:  CALL   0F8
071E:  MOVWF  78
071F:  MOVWF  23
....................  
....................          nokia_write_data(~chardata);  // send data to nokia 
0720:  MOVF   23,W
0721:  MOVWF  5E
0722:  COMF   5E,F
0723:  MOVF   5E,W
0724:  MOVWF  5F
0725:  CALL   426
0726:  INCF   20,F
0727:  GOTO   6F8
....................       } 
....................          nokia_write_data(0xff);      // 1 byte (always blank) 
0728:  MOVLW  FF
0729:  MOVWF  5F
072A:  CALL   426
.................... } 
.................... void LcdPixel (char x, char y) { 
....................     char offset; 
....................     byte  data; 
....................  
....................     if (x > 84) return; 
....................     if (y > 48) return; 
....................  
....................     offset = y % 8; 
....................     data = (0x01<<offset); 
....................          
....................     nokia_gotoxy(x, (y/8)); 
....................     nokia_write_data(data); 
.................... } 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0ED4:  BCF    03.6
0ED5:  CLRF   26
0ED6:  CLRF   27
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... int clock_mode=0; 
.................... int setting_mode=0; 
.................... int alarm_mode=0; 
....................  
.................... int num_edit=0; 
.................... int mode_list=0; 
.................... int h_alarm[5]={0,0,0,0,0}; 
0ED7:  CLRF   2D
0ED8:  CLRF   2E
0ED9:  CLRF   2F
0EDA:  CLRF   30
0EDB:  CLRF   31
.................... int m_alarm[5]={0,0,0,0,0}; 
0EDC:  CLRF   32
0EDD:  CLRF   33
0EDE:  CLRF   34
0EDF:  CLRF   35
0EE0:  CLRF   36
.................... const int alarm_list[5]={1,2,3,4,5}; 
.................... int h=2,m=4,s=45; 
.................... int h_edit=9,m_edit=56,day_edit=18,mth_edit=6,yea_edit=16,dow_edit=2; 
.................... byte day=5,mth=4,yea=15,dow=2; 
.................... byte set_alarm[5]={0,0,0,0,0}; 
0EE1:  CLRF   44
0EE2:  CLRF   45
0EE3:  CLRF   46
0EE4:  CLRF   47
0EE5:  CLRF   48
.................... int set_alarm_mode=0; 
.................... int set_time_mode=0; 
.................... int set_date_mode=0; 
.................... byte temp=0; 
.................... //const char *monday[7]={"Mon","Tue","Wea","Thu","Fri","Sat","Sun"}; 
.................... //char *alarm_char[2]={"ON ","OFF"}; 
....................  
.................... void alarm_warning(void); 
.................... void edit_time(int h, int m); 
.................... void edit_date(int d, int m,int y,int dayow); 
.................... void clock_screen(void); 
.................... void alarm_screen(void); 
.................... void menu_screen(void); 
.................... void log_screen(int n); 
.................... void set_alarm_screen(void); 
.................... void display_screen(void); 
.................... void alarm_edit(void); 
.................... void button_ok(int n); 
....................  
.................... void alarm_warning(){ 
*
0E6A:  CLRF   52
....................    int i=0; 
....................    for(i=0;i<30;i++){ 
0E6B:  CLRF   52
0E6C:  MOVF   52,W
0E6D:  SUBLW  1D
0E6E:  BTFSS  03.0
0E6F:  GOTO   69B
.................... //      printf("second %d ",s); 
....................       if(!input(MODE)){ 
0E70:  BSF    03.5
0E71:  BSF    06.0
0E72:  BCF    03.5
0E73:  BTFSC  06.0
0E74:  GOTO   682
....................          while(!input(MODE)){ 
0E75:  BSF    03.5
0E76:  BSF    06.0
0E77:  BCF    03.5
0E78:  BTFSC  06.0
0E79:  GOTO   680
....................             delay_ms(100); 
0E7A:  MOVLW  64
0E7B:  MOVWF  54
0E7C:  BCF    0A.3
0E7D:  CALL   3D5
0E7E:  BSF    0A.3
0E7F:  GOTO   675
....................          } 
....................          break; 
0E80:  GOTO   69B
....................       } 
0E81:  GOTO   699
....................       else{ 
....................          nokia_gotoxy(0,0); 
0E82:  CLRF   58
0E83:  CLRF   59
0E84:  BCF    0A.3
0E85:  CALL   419
0E86:  BSF    0A.3
....................          printf(nokia_printchar,"ALARM RING!"); 
0E87:  MOVLW  FB
0E88:  BSF    03.6
0E89:  MOVWF  0D
0E8A:  MOVLW  01
0E8B:  MOVWF  0F
0E8C:  BCF    0A.3
0E8D:  BCF    03.6
0E8E:  CALL   4FE
0E8F:  BSF    0A.3
....................          delay_ms(1000); 
0E90:  MOVLW  04
0E91:  MOVWF  53
0E92:  MOVLW  FA
0E93:  MOVWF  54
0E94:  BCF    0A.3
0E95:  CALL   3D5
0E96:  BSF    0A.3
0E97:  DECFSZ 53,F
0E98:  GOTO   692
....................       } 
0E99:  INCF   52,F
0E9A:  GOTO   66C
....................    } 
0E9B:  BSF    0A.3
0E9C:  BCF    0A.4
0E9D:  GOTO   799 (RETURN)
.................... } 
.................... void alarm_screen(){//hien thi danh sach alarm 
*
0C44:  CLRF   53
.................... int i=0; 
....................    nokia_gotoxy(0,0); 
0C45:  CLRF   58
0C46:  CLRF   59
0C47:  BCF    0A.3
0C48:  CALL   419
0C49:  BSF    0A.3
....................    printf(nokia_printchar,"ALARM SETTING"); 
0C4A:  MOVLW  01
0C4B:  BSF    03.6
0C4C:  MOVWF  0D
0C4D:  MOVLW  02
0C4E:  MOVWF  0F
0C4F:  BCF    0A.3
0C50:  BCF    03.6
0C51:  CALL   4FE
0C52:  BSF    0A.3
....................    if(mode_list<4){ 
0C53:  MOVF   2C,W
0C54:  SUBLW  03
0C55:  BTFSS  03.0
0C56:  GOTO   4AE
....................       for(i=0;i<4;i++){ 
0C57:  CLRF   53
0C58:  MOVF   53,W
0C59:  SUBLW  03
0C5A:  BTFSS  03.0
0C5B:  GOTO   4AD
....................          if(mode_list==i){ 
0C5C:  MOVF   53,W
0C5D:  SUBWF  2C,W
0C5E:  BTFSS  03.2
0C5F:  GOTO   48A
....................             nokia_gotoxy(0,1+i); 
0C60:  MOVLW  01
0C61:  ADDWF  53,W
0C62:  MOVWF  54
0C63:  CLRF   58
0C64:  MOVF   54,W
0C65:  MOVWF  59
0C66:  BCF    0A.3
0C67:  CALL   419
0C68:  BSF    0A.3
....................             printf(nokia_printchar_inverted,"ALARM %d       ",alarm_list[i]); 
0C69:  MOVF   53,W
0C6A:  BCF    0A.3
0C6B:  CALL   1F2
0C6C:  BSF    0A.3
0C6D:  MOVWF  54
0C6E:  MOVLW  08
0C6F:  BSF    03.6
0C70:  MOVWF  0D
0C71:  MOVLW  02
0C72:  MOVWF  0F
0C73:  BCF    03.0
0C74:  MOVLW  06
0C75:  BCF    03.6
0C76:  MOVWF  55
0C77:  CALL   079
0C78:  MOVF   54,W
0C79:  MOVWF  57
0C7A:  MOVLW  18
0C7B:  MOVWF  58
0C7C:  BCF    0A.3
0C7D:  CALL   782
0C7E:  BSF    0A.3
0C7F:  MOVLW  0C
0C80:  BSF    03.6
0C81:  MOVWF  0D
0C82:  MOVLW  02
0C83:  MOVWF  0F
0C84:  BCF    03.0
0C85:  MOVLW  07
0C86:  BCF    03.6
0C87:  MOVWF  55
0C88:  CALL   079
....................          }else{ 
0C89:  GOTO   4AB
....................             nokia_gotoxy(0,1+i); 
0C8A:  MOVLW  01
0C8B:  ADDWF  53,W
0C8C:  MOVWF  54
0C8D:  CLRF   58
0C8E:  MOVF   54,W
0C8F:  MOVWF  59
0C90:  BCF    0A.3
0C91:  CALL   419
0C92:  BSF    0A.3
....................             printf(nokia_printchar,"ALARM %d",alarm_list[i]); 
0C93:  MOVF   53,W
0C94:  BCF    0A.3
0C95:  CALL   1F2
0C96:  BSF    0A.3
0C97:  MOVWF  54
0C98:  MOVLW  10
0C99:  BSF    03.6
0C9A:  MOVWF  0D
0C9B:  MOVLW  02
0C9C:  MOVWF  0F
0C9D:  BCF    03.0
0C9E:  MOVLW  06
0C9F:  BCF    03.6
0CA0:  MOVWF  55
0CA1:  BCF    0A.3
0CA2:  CALL   652
0CA3:  BSF    0A.3
0CA4:  MOVF   54,W
0CA5:  MOVWF  57
0CA6:  MOVLW  18
0CA7:  MOVWF  58
0CA8:  BCF    0A.3
0CA9:  CALL   5FB
0CAA:  BSF    0A.3
....................          } 
0CAB:  INCF   53,F
0CAC:  GOTO   458
....................       } 
....................    }else if(mode_list==4){ 
0CAD:  GOTO   503
0CAE:  MOVF   2C,W
0CAF:  SUBLW  04
0CB0:  BTFSS  03.2
0CB1:  GOTO   503
....................       for(i=1;i<5;i++){ 
0CB2:  MOVLW  01
0CB3:  MOVWF  53
0CB4:  MOVF   53,W
0CB5:  SUBLW  04
0CB6:  BTFSS  03.0
0CB7:  GOTO   503
....................          if(mode_list==i){ 
0CB8:  MOVF   53,W
0CB9:  SUBWF  2C,W
0CBA:  BTFSS  03.2
0CBB:  GOTO   4E3
....................             nokia_gotoxy(0,i); 
0CBC:  CLRF   58
0CBD:  MOVF   53,W
0CBE:  MOVWF  59
0CBF:  BCF    0A.3
0CC0:  CALL   419
0CC1:  BSF    0A.3
....................             printf(nokia_printchar_inverted,"ALARM %d       ",alarm_list[i]); 
0CC2:  MOVF   53,W
0CC3:  BCF    0A.3
0CC4:  CALL   1F2
0CC5:  BSF    0A.3
0CC6:  MOVWF  54
0CC7:  MOVLW  15
0CC8:  BSF    03.6
0CC9:  MOVWF  0D
0CCA:  MOVLW  02
0CCB:  MOVWF  0F
0CCC:  BCF    03.0
0CCD:  MOVLW  06
0CCE:  BCF    03.6
0CCF:  MOVWF  55
0CD0:  CALL   079
0CD1:  MOVF   54,W
0CD2:  MOVWF  57
0CD3:  MOVLW  18
0CD4:  MOVWF  58
0CD5:  BCF    0A.3
0CD6:  CALL   782
0CD7:  BSF    0A.3
0CD8:  MOVLW  19
0CD9:  BSF    03.6
0CDA:  MOVWF  0D
0CDB:  MOVLW  02
0CDC:  MOVWF  0F
0CDD:  BCF    03.0
0CDE:  MOVLW  07
0CDF:  BCF    03.6
0CE0:  MOVWF  55
0CE1:  CALL   079
....................          }else{ 
0CE2:  GOTO   501
....................             nokia_gotoxy(0,i); 
0CE3:  CLRF   58
0CE4:  MOVF   53,W
0CE5:  MOVWF  59
0CE6:  BCF    0A.3
0CE7:  CALL   419
0CE8:  BSF    0A.3
....................             printf(nokia_printchar,"ALARM %d",alarm_list[i]); 
0CE9:  MOVF   53,W
0CEA:  BCF    0A.3
0CEB:  CALL   1F2
0CEC:  BSF    0A.3
0CED:  MOVWF  54
0CEE:  MOVLW  1D
0CEF:  BSF    03.6
0CF0:  MOVWF  0D
0CF1:  MOVLW  02
0CF2:  MOVWF  0F
0CF3:  BCF    03.0
0CF4:  MOVLW  06
0CF5:  BCF    03.6
0CF6:  MOVWF  55
0CF7:  BCF    0A.3
0CF8:  CALL   652
0CF9:  BSF    0A.3
0CFA:  MOVF   54,W
0CFB:  MOVWF  57
0CFC:  MOVLW  18
0CFD:  MOVWF  58
0CFE:  BCF    0A.3
0CFF:  CALL   5FB
0D00:  BSF    0A.3
....................          } 
0D01:  INCF   53,F
0D02:  GOTO   4B4
....................       }       
....................    } 
....................    button_ok(1); 
0D03:  MOVLW  01
0D04:  MOVWF  57
0D05:  BCF    0A.3
0D06:  CALL   6A9
0D07:  BSF    0A.3
.................... } 
.................... void button_ok(int n){ 
.................... if(n==0){ 
*
06A9:  MOVF   57,F
06AA:  BTFSS  03.2
06AB:  GOTO   6B8
....................     nokia_gotoxy (0, 5); 
06AC:  CLRF   58
06AD:  MOVLW  05
06AE:  MOVWF  59
06AF:  CALL   419
....................     printf (nokia_printchar, "MENU"); 
06B0:  MOVLW  22
06B1:  BSF    03.6
06B2:  MOVWF  0D
06B3:  MOVLW  02
06B4:  MOVWF  0F
06B5:  BCF    03.6
06B6:  CALL   4FE
.................... } 
06B7:  GOTO   6EC
.................... else if(n==1){ 
06B8:  DECFSZ 57,W
06B9:  GOTO   6C6
....................     nokia_gotoxy (0, 5); 
06BA:  CLRF   58
06BB:  MOVLW  05
06BC:  MOVWF  59
06BD:  CALL   419
....................     printf (nokia_printchar, "OK        BACK"); 
06BE:  MOVLW  25
06BF:  BSF    03.6
06C0:  MOVWF  0D
06C1:  MOVLW  02
06C2:  MOVWF  0F
06C3:  BCF    03.6
06C4:  CALL   4FE
.................... } 
06C5:  GOTO   6EC
.................... else if(n==2){ 
06C6:  MOVF   57,W
06C7:  SUBLW  02
06C8:  BTFSS  03.2
06C9:  GOTO   6D6
....................     nokia_gotoxy (0, 5); 
06CA:  CLRF   58
06CB:  MOVLW  05
06CC:  MOVWF  59
06CD:  CALL   419
....................     printf (nokia_printchar, "OK        NEXT"); 
06CE:  MOVLW  2D
06CF:  BSF    03.6
06D0:  MOVWF  0D
06D1:  MOVLW  02
06D2:  MOVWF  0F
06D3:  BCF    03.6
06D4:  CALL   4FE
.................... } 
06D5:  GOTO   6EC
.................... else{ 
....................     nokia_gotoxy (0, 2); 
06D6:  CLRF   58
06D7:  MOVLW  02
06D8:  MOVWF  59
06D9:  CALL   419
....................     printf (nokia_printchar, "Save your     change?"); 
06DA:  MOVLW  35
06DB:  BSF    03.6
06DC:  MOVWF  0D
06DD:  MOVLW  02
06DE:  MOVWF  0F
06DF:  BCF    03.6
06E0:  CALL   4FE
....................     nokia_gotoxy (0, 5); 
06E1:  CLRF   58
06E2:  MOVLW  05
06E3:  MOVWF  59
06E4:  CALL   419
....................     printf (nokia_printchar, "OK      CANCEL"); 
06E5:  MOVLW  40
06E6:  BSF    03.6
06E7:  MOVWF  0D
06E8:  MOVLW  02
06E9:  MOVWF  0F
06EA:  BCF    03.6
06EB:  CALL   4FE
.................... } 
06EC:  RETURN
.................... } 
.................... void clock_screen(){ 
*
08D7:  CLRF   52
08D8:  CLRF   53
....................       int i=0; 
....................       int set=0; 
....................        nokia_gotoxy (0, 1); 
08D9:  CLRF   58
08DA:  MOVLW  01
08DB:  MOVWF  59
08DC:  BCF    0A.3
08DD:  CALL   419
08DE:  BSF    0A.3
....................        if(day<10) 
08DF:  MOVF   40,W
08E0:  SUBLW  09
08E1:  BTFSS  03.0
08E2:  GOTO   0F0
....................          printf (nokia_printchar, "0%d",day); 
08E3:  MOVLW  30
08E4:  MOVWF  5D
08E5:  BCF    0A.3
08E6:  CALL   4C3
08E7:  BSF    0A.3
08E8:  MOVF   40,W
08E9:  MOVWF  57
08EA:  MOVLW  18
08EB:  MOVWF  58
08EC:  BCF    0A.3
08ED:  CALL   5FB
08EE:  BSF    0A.3
08EF:  GOTO   0F7
....................        else  
....................          printf (nokia_printchar, "%d",day); 
08F0:  MOVF   40,W
08F1:  MOVWF  57
08F2:  MOVLW  18
08F3:  MOVWF  58
08F4:  BCF    0A.3
08F5:  CALL   5FB
08F6:  BSF    0A.3
....................        if(mth<10) 
08F7:  MOVF   41,W
08F8:  SUBLW  09
08F9:  BTFSS  03.0
08FA:  GOTO   10D
....................          printf (nokia_printchar, "/0%d",mth); 
08FB:  MOVLW  2F
08FC:  MOVWF  5D
08FD:  BCF    0A.3
08FE:  CALL   4C3
08FF:  BSF    0A.3
0900:  MOVLW  30
0901:  MOVWF  5D
0902:  BCF    0A.3
0903:  CALL   4C3
0904:  BSF    0A.3
0905:  MOVF   41,W
0906:  MOVWF  57
0907:  MOVLW  18
0908:  MOVWF  58
0909:  BCF    0A.3
090A:  CALL   5FB
090B:  BSF    0A.3
090C:  GOTO   119
....................        else 
....................          printf (nokia_printchar, "/%d",mth); 
090D:  MOVLW  2F
090E:  MOVWF  5D
090F:  BCF    0A.3
0910:  CALL   4C3
0911:  BSF    0A.3
0912:  MOVF   41,W
0913:  MOVWF  57
0914:  MOVLW  18
0915:  MOVWF  58
0916:  BCF    0A.3
0917:  CALL   5FB
0918:  BSF    0A.3
....................        if(yea<10) 
0919:  MOVF   42,W
091A:  SUBLW  09
091B:  BTFSS  03.0
091C:  GOTO   131
....................          printf (nokia_printchar, "/200%d",yea); 
091D:  MOVLW  48
091E:  BSF    03.6
091F:  MOVWF  0D
0920:  MOVLW  02
0921:  MOVWF  0F
0922:  BCF    03.0
0923:  MOVLW  04
0924:  BCF    03.6
0925:  MOVWF  55
0926:  BCF    0A.3
0927:  CALL   652
0928:  BSF    0A.3
0929:  MOVF   42,W
092A:  MOVWF  57
092B:  MOVLW  18
092C:  MOVWF  58
092D:  BCF    0A.3
092E:  CALL   5FB
092F:  BSF    0A.3
0930:  GOTO   147
....................        else 
....................          printf (nokia_printchar, "/20%d",yea); 
0931:  MOVLW  2F
0932:  MOVWF  5D
0933:  BCF    0A.3
0934:  CALL   4C3
0935:  BSF    0A.3
0936:  MOVLW  32
0937:  MOVWF  5D
0938:  BCF    0A.3
0939:  CALL   4C3
093A:  BSF    0A.3
093B:  MOVLW  30
093C:  MOVWF  5D
093D:  BCF    0A.3
093E:  CALL   4C3
093F:  BSF    0A.3
0940:  MOVF   42,W
0941:  MOVWF  57
0942:  MOVLW  18
0943:  MOVWF  58
0944:  BCF    0A.3
0945:  CALL   5FB
0946:  BSF    0A.3
....................        nokia_gotoxy (0, 2); 
0947:  CLRF   58
0948:  MOVLW  02
0949:  MOVWF  59
094A:  BCF    0A.3
094B:  CALL   419
094C:  BSF    0A.3
....................        if(h<10) 
094D:  MOVF   37,W
094E:  SUBLW  09
094F:  BTFSS  03.0
0950:  GOTO   15E
....................          printf (nokia_printchar, "0%d",h); 
0951:  MOVLW  30
0952:  MOVWF  5D
0953:  BCF    0A.3
0954:  CALL   4C3
0955:  BSF    0A.3
0956:  MOVF   37,W
0957:  MOVWF  57
0958:  MOVLW  18
0959:  MOVWF  58
095A:  BCF    0A.3
095B:  CALL   5FB
095C:  BSF    0A.3
095D:  GOTO   165
....................        else  
....................          printf (nokia_printchar, "%d",h); 
095E:  MOVF   37,W
095F:  MOVWF  57
0960:  MOVLW  18
0961:  MOVWF  58
0962:  BCF    0A.3
0963:  CALL   5FB
0964:  BSF    0A.3
....................        if(m<10) 
0965:  MOVF   38,W
0966:  SUBLW  09
0967:  BTFSS  03.0
0968:  GOTO   17B
....................          printf (nokia_printchar, ":0%d",m); 
0969:  MOVLW  3A
096A:  MOVWF  5D
096B:  BCF    0A.3
096C:  CALL   4C3
096D:  BSF    0A.3
096E:  MOVLW  30
096F:  MOVWF  5D
0970:  BCF    0A.3
0971:  CALL   4C3
0972:  BSF    0A.3
0973:  MOVF   38,W
0974:  MOVWF  57
0975:  MOVLW  18
0976:  MOVWF  58
0977:  BCF    0A.3
0978:  CALL   5FB
0979:  BSF    0A.3
097A:  GOTO   187
....................        else 
....................          printf (nokia_printchar, ":%d",m); 
097B:  MOVLW  3A
097C:  MOVWF  5D
097D:  BCF    0A.3
097E:  CALL   4C3
097F:  BSF    0A.3
0980:  MOVF   38,W
0981:  MOVWF  57
0982:  MOVLW  18
0983:  MOVWF  58
0984:  BCF    0A.3
0985:  CALL   5FB
0986:  BSF    0A.3
....................        if(s<10) 
0987:  MOVF   39,W
0988:  SUBLW  09
0989:  BTFSS  03.0
098A:  GOTO   19D
....................          printf (nokia_printchar, ":0%d",s); 
098B:  MOVLW  3A
098C:  MOVWF  5D
098D:  BCF    0A.3
098E:  CALL   4C3
098F:  BSF    0A.3
0990:  MOVLW  30
0991:  MOVWF  5D
0992:  BCF    0A.3
0993:  CALL   4C3
0994:  BSF    0A.3
0995:  MOVF   39,W
0996:  MOVWF  57
0997:  MOVLW  18
0998:  MOVWF  58
0999:  BCF    0A.3
099A:  CALL   5FB
099B:  BSF    0A.3
099C:  GOTO   1A9
....................        else 
....................          printf (nokia_printchar, ":%d",s);        
099D:  MOVLW  3A
099E:  MOVWF  5D
099F:  BCF    0A.3
09A0:  CALL   4C3
09A1:  BSF    0A.3
09A2:  MOVF   39,W
09A3:  MOVWF  57
09A4:  MOVLW  18
09A5:  MOVWF  58
09A6:  BCF    0A.3
09A7:  CALL   5FB
09A8:  BSF    0A.3
....................        nokia_gotoxy (0, 3); 
09A9:  CLRF   58
09AA:  MOVLW  03
09AB:  MOVWF  59
09AC:  BCF    0A.3
09AD:  CALL   419
09AE:  BSF    0A.3
....................        if(temp<10) 
09AF:  MOVF   4C,W
09B0:  SUBLW  09
09B1:  BTFSS  03.0
09B2:  GOTO   1CA
....................          printf (nokia_printchar, "0%d~C",temp); 
09B3:  MOVLW  30
09B4:  MOVWF  5D
09B5:  BCF    0A.3
09B6:  CALL   4C3
09B7:  BSF    0A.3
09B8:  MOVF   4C,W
09B9:  MOVWF  57
09BA:  MOVLW  18
09BB:  MOVWF  58
09BC:  BCF    0A.3
09BD:  CALL   5FB
09BE:  BSF    0A.3
09BF:  MOVLW  7E
09C0:  MOVWF  5D
09C1:  BCF    0A.3
09C2:  CALL   4C3
09C3:  BSF    0A.3
09C4:  MOVLW  43
09C5:  MOVWF  5D
09C6:  BCF    0A.3
09C7:  CALL   4C3
09C8:  BSF    0A.3
09C9:  GOTO   1DB
....................        else  
....................          printf (nokia_printchar, "%d~C",temp); 
09CA:  MOVF   4C,W
09CB:  MOVWF  57
09CC:  MOVLW  18
09CD:  MOVWF  58
09CE:  BCF    0A.3
09CF:  CALL   5FB
09D0:  BSF    0A.3
09D1:  MOVLW  7E
09D2:  MOVWF  5D
09D3:  BCF    0A.3
09D4:  CALL   4C3
09D5:  BSF    0A.3
09D6:  MOVLW  43
09D7:  MOVWF  5D
09D8:  BCF    0A.3
09D9:  CALL   4C3
09DA:  BSF    0A.3
....................        nokia_gotoxy (0, 4);     
09DB:  CLRF   58
09DC:  MOVLW  04
09DD:  MOVWF  59
09DE:  BCF    0A.3
09DF:  CALL   419
09E0:  BSF    0A.3
....................        for(i=0;i<5;i++) 
09E1:  CLRF   52
09E2:  MOVF   52,W
09E3:  SUBLW  04
09E4:  BTFSS  03.0
09E5:  GOTO   1F3
....................        if(set_alarm[i]==1){ 
09E6:  MOVLW  44
09E7:  ADDWF  52,W
09E8:  MOVWF  04
09E9:  BCF    03.7
09EA:  DECFSZ 00,W
09EB:  GOTO   1F0
....................          set=1; 
09EC:  MOVLW  01
09ED:  MOVWF  53
....................          break; 
09EE:  GOTO   1F3
....................        }else set=0; 
09EF:  GOTO   1F1
09F0:  CLRF   53
09F1:  INCF   52,F
09F2:  GOTO   1E2
....................        if(set==1) 
09F3:  DECFSZ 53,W
09F4:  GOTO   1FF
....................          printf (nokia_printchar,"ALARM ON");  
09F5:  MOVLW  4C
09F6:  BSF    03.6
09F7:  MOVWF  0D
09F8:  MOVLW  02
09F9:  MOVWF  0F
09FA:  BCF    0A.3
09FB:  BCF    03.6
09FC:  CALL   4FE
09FD:  BSF    0A.3
09FE:  GOTO   208
....................         
....................        else printf (nokia_printchar,"ALARM OFF"); 
09FF:  MOVLW  51
0A00:  BSF    03.6
0A01:  MOVWF  0D
0A02:  MOVLW  02
0A03:  MOVWF  0F
0A04:  BCF    0A.3
0A05:  BCF    03.6
0A06:  CALL   4FE
0A07:  BSF    0A.3
....................        button_ok(0); 
0A08:  CLRF   57
0A09:  BCF    0A.3
0A0A:  CALL   6A9
0A0B:  BSF    0A.3
.................... } 
.................... void menu_screen(){//hie thi man hinh menu 
....................        nokia_gotoxy (0, 0); 
*
0A13:  CLRF   58
0A14:  CLRF   59
0A15:  BCF    0A.3
0A16:  CALL   419
0A17:  BSF    0A.3
....................        printf (nokia_printchar, "   SETTINGS   "); 
0A18:  MOVLW  56
0A19:  BSF    03.6
0A1A:  MOVWF  0D
0A1B:  MOVLW  02
0A1C:  MOVWF  0F
0A1D:  BCF    0A.3
0A1E:  BCF    03.6
0A1F:  CALL   4FE
0A20:  BSF    0A.3
....................        nokia_gotoxy (0, 1); 
0A21:  CLRF   58
0A22:  MOVLW  01
0A23:  MOVWF  59
0A24:  BCF    0A.3
0A25:  CALL   419
0A26:  BSF    0A.3
....................        if(mode_list==0) 
0A27:  MOVF   2C,F
0A28:  BTFSS  03.2
0A29:  GOTO   234
....................          printf (nokia_printchar_inverted, "Adjust time   "); 
0A2A:  MOVLW  5E
0A2B:  BSF    03.6
0A2C:  MOVWF  0D
0A2D:  MOVLW  02
0A2E:  MOVWF  0F
0A2F:  BCF    0A.3
0A30:  BCF    03.6
0A31:  CALL   72C
0A32:  BSF    0A.3
0A33:  GOTO   23D
....................        else{ 
....................          printf (nokia_printchar, "Adjust time"); 
0A34:  MOVLW  66
0A35:  BSF    03.6
0A36:  MOVWF  0D
0A37:  MOVLW  02
0A38:  MOVWF  0F
0A39:  BCF    0A.3
0A3A:  BCF    03.6
0A3B:  CALL   4FE
0A3C:  BSF    0A.3
....................        } 
....................        nokia_gotoxy (0, 2); 
0A3D:  CLRF   58
0A3E:  MOVLW  02
0A3F:  MOVWF  59
0A40:  BCF    0A.3
0A41:  CALL   419
0A42:  BSF    0A.3
....................        if(mode_list==1) 
0A43:  DECFSZ 2C,W
0A44:  GOTO   24F
....................          printf (nokia_printchar_inverted, "Adjust date   "); 
0A45:  MOVLW  6C
0A46:  BSF    03.6
0A47:  MOVWF  0D
0A48:  MOVLW  02
0A49:  MOVWF  0F
0A4A:  BCF    0A.3
0A4B:  BCF    03.6
0A4C:  CALL   72C
0A4D:  BSF    0A.3
0A4E:  GOTO   258
....................        else{ 
....................          printf (nokia_printchar, "Adjust date"); 
0A4F:  MOVLW  74
0A50:  BSF    03.6
0A51:  MOVWF  0D
0A52:  MOVLW  02
0A53:  MOVWF  0F
0A54:  BCF    0A.3
0A55:  BCF    03.6
0A56:  CALL   4FE
0A57:  BSF    0A.3
....................        } 
....................        nokia_gotoxy (0, 3); 
0A58:  CLRF   58
0A59:  MOVLW  03
0A5A:  MOVWF  59
0A5B:  BCF    0A.3
0A5C:  CALL   419
0A5D:  BSF    0A.3
....................        if(mode_list==2) 
0A5E:  MOVF   2C,W
0A5F:  SUBLW  02
0A60:  BTFSS  03.2
0A61:  GOTO   26C
....................          printf (nokia_printchar_inverted, "Set alarm     "); 
0A62:  MOVLW  7A
0A63:  BSF    03.6
0A64:  MOVWF  0D
0A65:  MOVLW  02
0A66:  MOVWF  0F
0A67:  BCF    0A.3
0A68:  BCF    03.6
0A69:  CALL   72C
0A6A:  BSF    0A.3
0A6B:  GOTO   275
....................        else{ 
....................          printf (nokia_printchar, "Set alarm"); 
0A6C:  MOVLW  82
0A6D:  BSF    03.6
0A6E:  MOVWF  0D
0A6F:  MOVLW  02
0A70:  MOVWF  0F
0A71:  BCF    0A.3
0A72:  BCF    03.6
0A73:  CALL   4FE
0A74:  BSF    0A.3
....................        }   
....................        button_ok(1); 
0A75:  MOVLW  01
0A76:  MOVWF  57
0A77:  BCF    0A.3
0A78:  CALL   6A9
0A79:  BSF    0A.3
.................... } 
.................... void log_screen(int n){//man hinh thong bao 
....................       nokia_clean_ddram(); 
*
0554:  CALL   43A
....................       nokia_gotoxy(0,0); 
0555:  CLRF   58
0556:  CLRF   59
0557:  CALL   419
....................    switch(n){ 
0558:  MOVF   52,W
0559:  BTFSC  03.2
055A:  GOTO   562
055B:  XORLW  01
055C:  BTFSC  03.2
055D:  GOTO   56A
055E:  XORLW  03
055F:  BTFSC  03.2
0560:  GOTO   572
0561:  GOTO   57A
....................       case 0: printf (nokia_printchar, "Time was saved"); 
0562:  MOVLW  87
0563:  BSF    03.6
0564:  MOVWF  0D
0565:  MOVLW  02
0566:  MOVWF  0F
0567:  BCF    03.6
0568:  CALL   4FE
....................       break; 
0569:  GOTO   581
....................       case 1: printf (nokia_printchar, "Date was saved"); 
056A:  MOVLW  8F
056B:  BSF    03.6
056C:  MOVWF  0D
056D:  MOVLW  02
056E:  MOVWF  0F
056F:  BCF    03.6
0570:  CALL   4FE
....................       break; 
0571:  GOTO   581
....................       case 2: printf (nokia_printchar, "Alarm was set"); 
0572:  MOVLW  97
0573:  BSF    03.6
0574:  MOVWF  0D
0575:  MOVLW  02
0576:  MOVWF  0F
0577:  BCF    03.6
0578:  CALL   4FE
....................       break; 
0579:  GOTO   581
....................       default: printf (nokia_printchar,"The action was saved in SD   card"); 
057A:  MOVLW  9E
057B:  BSF    03.6
057C:  MOVWF  0D
057D:  MOVLW  02
057E:  MOVWF  0F
057F:  BCF    03.6
0580:  CALL   4FE
....................       break; 
....................    } 
....................    delay_ms(1000); 
0581:  MOVLW  04
0582:  MOVWF  53
0583:  MOVLW  FA
0584:  MOVWF  54
0585:  CALL   3D5
0586:  DECFSZ 53,F
0587:  GOTO   583
0588:  RETURN
.................... } 
....................  
.................... void display_screen(){//dieu khien viec hien thi cac man hinh 
....................  
....................     if(clock_mode==0){  
*
08D4:  MOVF   28,F
08D5:  BTFSS  03.2
08D6:  GOTO   20D
....................        clock_screen(); 
....................     } 
*
0A0C:  GOTO   5CE
....................     else{ 
....................       switch(setting_mode){ 
0A0D:  MOVF   29,W
0A0E:  ADDLW  FC
0A0F:  BTFSC  03.0
0A10:  GOTO   5CE
0A11:  ADDLW  04
0A12:  GOTO   5CF
....................       case 0: 
....................          menu_screen(); 
....................          break; 
*
0A7A:  GOTO   5CE
....................       case 1:   if(set_time_mode==0)//man hinh chinh thoi gian 
0A7B:  MOVF   4A,F
0A7C:  BTFSS  03.2
0A7D:  GOTO   284
....................                   edit_time(h_edit,m_edit); 
0A7E:  MOVF   3A,W
0A7F:  MOVWF  55
0A80:  MOVF   3B,W
0A81:  MOVWF  56
0A82:  CALL   000
0A83:  GOTO   289
....................                else 
....................                   button_ok(3);//tuy chon luu thay doi 
0A84:  MOVLW  03
0A85:  MOVWF  57
0A86:  BCF    0A.3
0A87:  CALL   6A9
0A88:  BSF    0A.3
....................                break; 
0A89:  GOTO   5CE
....................       case 2: if(set_date_mode==0)//man hinh chinh ngay 
0A8A:  MOVF   4B,F
0A8B:  BTFSS  03.2
0A8C:  GOTO   43A
....................                edit_date(day_edit,mth_edit,yea_edit,dow_edit); 
0A8D:  MOVF   3C,W
0A8E:  MOVWF  52
0A8F:  MOVF   3D,W
0A90:  MOVWF  53
0A91:  MOVF   3E,W
0A92:  MOVWF  54
0A93:  MOVF   3F,W
0A94:  MOVWF  55
*
0C39:  GOTO   43F
....................               else 
....................               button_ok(3);//luu hay khong 
0C3A:  MOVLW  03
0C3B:  MOVWF  57
0C3C:  BCF    0A.3
0C3D:  CALL   6A9
0C3E:  BSF    0A.3
....................               break; 
0C3F:  GOTO   5CE
....................       case 3:  alarm_edit();               
....................          break; 
....................           
....................       } 
....................         
....................     } 
*
0DCE:  RETURN
.................... } 
.................... void set_alarm_screen(int i){//man hinh tuy chon luu cai dat alarm 
....................     nokia_gotoxy (0, 0); 
*
0D6A:  CLRF   58
0D6B:  CLRF   59
0D6C:  BCF    0A.3
0D6D:  CALL   419
0D6E:  BSF    0A.3
....................     printf (nokia_printchar, " EDIT ALARM %d ",i); 
0D6F:  MOVLW  AF
0D70:  BSF    03.6
0D71:  MOVWF  0D
0D72:  MOVLW  02
0D73:  MOVWF  0F
0D74:  BCF    03.0
0D75:  MOVLW  0C
0D76:  BCF    03.6
0D77:  MOVWF  55
0D78:  BCF    0A.3
0D79:  CALL   652
0D7A:  BSF    0A.3
0D7B:  MOVF   53,W
0D7C:  MOVWF  57
0D7D:  MOVLW  18
0D7E:  MOVWF  58
0D7F:  BCF    0A.3
0D80:  CALL   5FB
0D81:  BSF    0A.3
0D82:  MOVLW  20
0D83:  MOVWF  5D
0D84:  BCF    0A.3
0D85:  CALL   4C3
0D86:  BSF    0A.3
....................     if(mode_list==0){ 
0D87:  MOVF   2C,F
0D88:  BTFSS  03.2
0D89:  GOTO   5A9
....................        nokia_gotoxy (0, 1); 
0D8A:  CLRF   58
0D8B:  MOVLW  01
0D8C:  MOVWF  59
0D8D:  BCF    0A.3
0D8E:  CALL   419
0D8F:  BSF    0A.3
....................        printf (nokia_printchar_inverted, "Set alarm on "); 
0D90:  MOVLW  B7
0D91:  BSF    03.6
0D92:  MOVWF  0D
0D93:  MOVLW  02
0D94:  MOVWF  0F
0D95:  BCF    0A.3
0D96:  BCF    03.6
0D97:  CALL   72C
0D98:  BSF    0A.3
....................        nokia_gotoxy (0, 2); 
0D99:  CLRF   58
0D9A:  MOVLW  02
0D9B:  MOVWF  59
0D9C:  BCF    0A.3
0D9D:  CALL   419
0D9E:  BSF    0A.3
....................        printf (nokia_printchar, "Set alarm off"); 
0D9F:  MOVLW  BE
0DA0:  BSF    03.6
0DA1:  MOVWF  0D
0DA2:  MOVLW  02
0DA3:  MOVWF  0F
0DA4:  BCF    0A.3
0DA5:  BCF    03.6
0DA6:  CALL   4FE
0DA7:  BSF    0A.3
....................     }else{ 
0DA8:  GOTO   5C7
....................        nokia_gotoxy (0, 1); 
0DA9:  CLRF   58
0DAA:  MOVLW  01
0DAB:  MOVWF  59
0DAC:  BCF    0A.3
0DAD:  CALL   419
0DAE:  BSF    0A.3
....................        printf (nokia_printchar, "Set alarm on "); 
0DAF:  MOVLW  C5
0DB0:  BSF    03.6
0DB1:  MOVWF  0D
0DB2:  MOVLW  02
0DB3:  MOVWF  0F
0DB4:  BCF    0A.3
0DB5:  BCF    03.6
0DB6:  CALL   4FE
0DB7:  BSF    0A.3
....................        nokia_gotoxy (0, 2); 
0DB8:  CLRF   58
0DB9:  MOVLW  02
0DBA:  MOVWF  59
0DBB:  BCF    0A.3
0DBC:  CALL   419
0DBD:  BSF    0A.3
....................        printf (nokia_printchar_inverted, "Set alarm off");     
0DBE:  MOVLW  CC
0DBF:  BSF    03.6
0DC0:  MOVWF  0D
0DC1:  MOVLW  02
0DC2:  MOVWF  0F
0DC3:  BCF    0A.3
0DC4:  BCF    03.6
0DC5:  CALL   72C
0DC6:  BSF    0A.3
....................     } 
....................     button_ok(1); 
0DC7:  MOVLW  01
0DC8:  MOVWF  57
0DC9:  BCF    0A.3
0DCA:  CALL   6A9
0DCB:  BSF    0A.3
.................... } 
.................... void alarm_edit(){//hien thi tuy chon chinh alarm 
*
0C40:  CLRF   52
.................... int i=0; 
....................    if(alarm_mode==0){ 
0C41:  MOVF   2A,F
0C42:  BTFSS  03.2
0C43:  GOTO   509
....................       alarm_screen(); 
....................    }else{ 
*
0D08:  GOTO   5CE
....................       for(i=1;i<6;i++){ 
0D09:  MOVLW  01
0D0A:  MOVWF  52
0D0B:  MOVF   52,W
0D0C:  SUBLW  05
0D0D:  BTFSS  03.0
0D0E:  GOTO   5CE
....................          if(alarm_mode==i){ 
0D0F:  MOVF   52,W
0D10:  SUBWF  2A,W
0D11:  BTFSS  03.2
0D12:  GOTO   5CC
....................             if(set_alarm_mode==0){             
0D13:  MOVF   49,F
0D14:  BTFSS  03.2
0D15:  GOTO   568
....................                nokia_gotoxy (0, 0); 
0D16:  CLRF   58
0D17:  CLRF   59
0D18:  BCF    0A.3
0D19:  CALL   419
0D1A:  BSF    0A.3
....................                printf (nokia_printchar, " EDIT ALARM %d ",i); 
0D1B:  MOVLW  D3
0D1C:  BSF    03.6
0D1D:  MOVWF  0D
0D1E:  MOVLW  02
0D1F:  MOVWF  0F
0D20:  BCF    03.0
0D21:  MOVLW  0C
0D22:  BCF    03.6
0D23:  MOVWF  55
0D24:  BCF    0A.3
0D25:  CALL   652
0D26:  BSF    0A.3
0D27:  MOVF   52,W
0D28:  MOVWF  57
0D29:  MOVLW  18
0D2A:  MOVWF  58
0D2B:  BCF    0A.3
0D2C:  CALL   5FB
0D2D:  BSF    0A.3
0D2E:  MOVLW  20
0D2F:  MOVWF  5D
0D30:  BCF    0A.3
0D31:  CALL   4C3
0D32:  BSF    0A.3
....................                edit_time(h_alarm[i-1], m_alarm[i-1]); 
0D33:  MOVLW  01
0D34:  SUBWF  52,W
0D35:  ADDLW  2D
0D36:  MOVWF  04
0D37:  BCF    03.7
0D38:  MOVF   00,W
0D39:  MOVWF  53
0D3A:  MOVLW  01
0D3B:  SUBWF  52,W
0D3C:  ADDLW  32
0D3D:  MOVWF  04
0D3E:  BCF    03.7
0D3F:  MOVF   00,W
0D40:  MOVWF  54
0D41:  MOVF   53,W
0D42:  MOVWF  55
0D43:  MOVF   54,W
0D44:  MOVWF  56
0D45:  CALL   000
....................                nokia_gotoxy(5,3);                
0D46:  MOVLW  05
0D47:  MOVWF  58
0D48:  MOVLW  03
0D49:  MOVWF  59
0D4A:  BCF    0A.3
0D4B:  CALL   419
0D4C:  BSF    0A.3
....................                if(set_alarm[i-1]==1) 
0D4D:  MOVLW  01
0D4E:  SUBWF  52,W
0D4F:  ADDLW  44
0D50:  MOVWF  04
0D51:  BCF    03.7
0D52:  DECFSZ 00,W
0D53:  GOTO   55E
....................                   printf(nokia_printchar,"Alarm on"); 
0D54:  MOVLW  DB
0D55:  BSF    03.6
0D56:  MOVWF  0D
0D57:  MOVLW  02
0D58:  MOVWF  0F
0D59:  BCF    0A.3
0D5A:  BCF    03.6
0D5B:  CALL   4FE
0D5C:  BSF    0A.3
0D5D:  GOTO   567
....................                else 
....................                   printf(nokia_printchar,"Alarm off"); 
0D5E:  MOVLW  E0
0D5F:  BSF    03.6
0D60:  MOVWF  0D
0D61:  MOVLW  02
0D62:  MOVWF  0F
0D63:  BCF    0A.3
0D64:  BCF    03.6
0D65:  CALL   4FE
0D66:  BSF    0A.3
....................             } 
0D67:  GOTO   5CC
....................             else  
....................             set_alarm_screen(alarm_mode); 
0D68:  MOVF   2A,W
0D69:  MOVWF  53
....................          } 
*
0DCC:  INCF   52,F
0DCD:  GOTO   50B
....................       } 
....................    } 
.................... } 
.................... void edit_time(int h, int m){//man hinh chinh gio 
....................    nokia_gotoxy (5, 2); 
*
0800:  MOVLW  05
0801:  MOVWF  58
0802:  MOVLW  02
0803:  MOVWF  59
0804:  BCF    0A.3
0805:  CALL   419
0806:  BSF    0A.3
....................    if(num_edit==0) 
0807:  MOVF   2B,F
0808:  BTFSS  03.2
0809:  GOTO   023
....................       if(h<10) 
080A:  MOVF   55,W
080B:  SUBLW  09
080C:  BTFSS  03.0
080D:  GOTO   01B
....................          printf (nokia_printchar_inverted, "0%d",h); 
080E:  MOVLW  30
080F:  MOVWF  5D
0810:  BCF    0A.3
0811:  CALL   6ED
0812:  BSF    0A.3
0813:  MOVF   55,W
0814:  MOVWF  57
0815:  MOVLW  18
0816:  MOVWF  58
0817:  BCF    0A.3
0818:  CALL   782
0819:  BSF    0A.3
081A:  GOTO   022
....................       else 
....................          printf (nokia_printchar_inverted, "%d",h); 
081B:  MOVF   55,W
081C:  MOVWF  57
081D:  MOVLW  18
081E:  MOVWF  58
081F:  BCF    0A.3
0820:  CALL   782
0821:  BSF    0A.3
0822:  GOTO   03B
....................    else 
....................       if(h<10) 
0823:  MOVF   55,W
0824:  SUBLW  09
0825:  BTFSS  03.0
0826:  GOTO   034
....................          printf (nokia_printchar, "0%d",h); 
0827:  MOVLW  30
0828:  MOVWF  5D
0829:  BCF    0A.3
082A:  CALL   4C3
082B:  BSF    0A.3
082C:  MOVF   55,W
082D:  MOVWF  57
082E:  MOVLW  18
082F:  MOVWF  58
0830:  BCF    0A.3
0831:  CALL   5FB
0832:  BSF    0A.3
0833:  GOTO   03B
....................       else  
....................          printf (nokia_printchar, "%d",h);  
0834:  MOVF   55,W
0835:  MOVWF  57
0836:  MOVLW  18
0837:  MOVWF  58
0838:  BCF    0A.3
0839:  CALL   5FB
083A:  BSF    0A.3
....................    printf (nokia_printchar, ":"); 
083B:  MOVLW  3A
083C:  MOVWF  5D
083D:  BCF    0A.3
083E:  CALL   4C3
083F:  BSF    0A.3
....................    if(num_edit==1) 
0840:  DECFSZ 2B,W
0841:  GOTO   05B
....................       if(m<10) 
0842:  MOVF   56,W
0843:  SUBLW  09
0844:  BTFSS  03.0
0845:  GOTO   053
....................          printf (nokia_printchar_inverted, "0%d",m); 
0846:  MOVLW  30
0847:  MOVWF  5D
0848:  BCF    0A.3
0849:  CALL   6ED
084A:  BSF    0A.3
084B:  MOVF   56,W
084C:  MOVWF  57
084D:  MOVLW  18
084E:  MOVWF  58
084F:  BCF    0A.3
0850:  CALL   782
0851:  BSF    0A.3
0852:  GOTO   05A
....................       else  
....................          printf (nokia_printchar_inverted, "%d",m); 
0853:  MOVF   56,W
0854:  MOVWF  57
0855:  MOVLW  18
0856:  MOVWF  58
0857:  BCF    0A.3
0858:  CALL   782
0859:  BSF    0A.3
085A:  GOTO   073
....................    else  
....................       if(m<10) 
085B:  MOVF   56,W
085C:  SUBLW  09
085D:  BTFSS  03.0
085E:  GOTO   06C
....................          printf (nokia_printchar, "0%d",m); 
085F:  MOVLW  30
0860:  MOVWF  5D
0861:  BCF    0A.3
0862:  CALL   4C3
0863:  BSF    0A.3
0864:  MOVF   56,W
0865:  MOVWF  57
0866:  MOVLW  18
0867:  MOVWF  58
0868:  BCF    0A.3
0869:  CALL   5FB
086A:  BSF    0A.3
086B:  GOTO   073
....................       else  
....................          printf (nokia_printchar, "%d",m); 
086C:  MOVF   56,W
086D:  MOVWF  57
086E:  MOVLW  18
086F:  MOVWF  58
0870:  BCF    0A.3
0871:  CALL   5FB
0872:  BSF    0A.3
....................    button_ok(2); 
0873:  MOVLW  02
0874:  MOVWF  57
0875:  BCF    0A.3
0876:  CALL   6A9
0877:  BSF    0A.3
0878:  RETURN
.................... } 
.................... void edit_date(int d, int m,int y,int dayow){//man hinh chinh ngay thang 
....................    nokia_gotoxy (0, 0); 
*
0A95:  CLRF   58
0A96:  CLRF   59
0A97:  BCF    0A.3
0A98:  CALL   419
0A99:  BSF    0A.3
....................    printf (nokia_printchar, "   EDIT DATE   "); 
0A9A:  MOVLW  E5
0A9B:  BSF    03.6
0A9C:  MOVWF  0D
0A9D:  MOVLW  02
0A9E:  MOVWF  0F
0A9F:  BCF    0A.3
0AA0:  BCF    03.6
0AA1:  CALL   4FE
0AA2:  BSF    0A.3
....................    nokia_gotoxy (0, 2); 
0AA3:  CLRF   58
0AA4:  MOVLW  02
0AA5:  MOVWF  59
0AA6:  BCF    0A.3
0AA7:  CALL   419
0AA8:  BSF    0A.3
....................    if(num_edit==0) 
0AA9:  MOVF   2B,F
0AAA:  BTFSS  03.2
0AAB:  GOTO   2C5
....................       if(d<10) 
0AAC:  MOVF   52,W
0AAD:  SUBLW  09
0AAE:  BTFSS  03.0
0AAF:  GOTO   2BD
....................          printf (nokia_printchar_inverted, "0%d",d); 
0AB0:  MOVLW  30
0AB1:  MOVWF  5D
0AB2:  BCF    0A.3
0AB3:  CALL   6ED
0AB4:  BSF    0A.3
0AB5:  MOVF   52,W
0AB6:  MOVWF  57
0AB7:  MOVLW  18
0AB8:  MOVWF  58
0AB9:  BCF    0A.3
0ABA:  CALL   782
0ABB:  BSF    0A.3
0ABC:  GOTO   2C4
....................       else  
....................          printf (nokia_printchar_inverted, "%d",d); 
0ABD:  MOVF   52,W
0ABE:  MOVWF  57
0ABF:  MOVLW  18
0AC0:  MOVWF  58
0AC1:  BCF    0A.3
0AC2:  CALL   782
0AC3:  BSF    0A.3
0AC4:  GOTO   2DD
....................    else 
....................       if(d<10) 
0AC5:  MOVF   52,W
0AC6:  SUBLW  09
0AC7:  BTFSS  03.0
0AC8:  GOTO   2D6
....................          printf (nokia_printchar, "0%d",d); 
0AC9:  MOVLW  30
0ACA:  MOVWF  5D
0ACB:  BCF    0A.3
0ACC:  CALL   4C3
0ACD:  BSF    0A.3
0ACE:  MOVF   52,W
0ACF:  MOVWF  57
0AD0:  MOVLW  18
0AD1:  MOVWF  58
0AD2:  BCF    0A.3
0AD3:  CALL   5FB
0AD4:  BSF    0A.3
0AD5:  GOTO   2DD
....................       else  
....................          printf (nokia_printchar, "%d",d); 
0AD6:  MOVF   52,W
0AD7:  MOVWF  57
0AD8:  MOVLW  18
0AD9:  MOVWF  58
0ADA:  BCF    0A.3
0ADB:  CALL   5FB
0ADC:  BSF    0A.3
....................    printf (nokia_printchar, "/"); 
0ADD:  MOVLW  2F
0ADE:  MOVWF  5D
0ADF:  BCF    0A.3
0AE0:  CALL   4C3
0AE1:  BSF    0A.3
....................    if(num_edit==1) 
0AE2:  DECFSZ 2B,W
0AE3:  GOTO   2FD
....................       if(m<10) 
0AE4:  MOVF   53,W
0AE5:  SUBLW  09
0AE6:  BTFSS  03.0
0AE7:  GOTO   2F5
....................          printf (nokia_printchar_inverted, "0%d",m); 
0AE8:  MOVLW  30
0AE9:  MOVWF  5D
0AEA:  BCF    0A.3
0AEB:  CALL   6ED
0AEC:  BSF    0A.3
0AED:  MOVF   53,W
0AEE:  MOVWF  57
0AEF:  MOVLW  18
0AF0:  MOVWF  58
0AF1:  BCF    0A.3
0AF2:  CALL   782
0AF3:  BSF    0A.3
0AF4:  GOTO   2FC
....................       else  
....................          printf (nokia_printchar_inverted, "%d",m); 
0AF5:  MOVF   53,W
0AF6:  MOVWF  57
0AF7:  MOVLW  18
0AF8:  MOVWF  58
0AF9:  BCF    0A.3
0AFA:  CALL   782
0AFB:  BSF    0A.3
0AFC:  GOTO   315
....................    else  
....................       if(m<10) 
0AFD:  MOVF   53,W
0AFE:  SUBLW  09
0AFF:  BTFSS  03.0
0B00:  GOTO   30E
....................          printf (nokia_printchar, "0%d",m); 
0B01:  MOVLW  30
0B02:  MOVWF  5D
0B03:  BCF    0A.3
0B04:  CALL   4C3
0B05:  BSF    0A.3
0B06:  MOVF   53,W
0B07:  MOVWF  57
0B08:  MOVLW  18
0B09:  MOVWF  58
0B0A:  BCF    0A.3
0B0B:  CALL   5FB
0B0C:  BSF    0A.3
0B0D:  GOTO   315
....................       else  
....................          printf (nokia_printchar, "%d",m); 
0B0E:  MOVF   53,W
0B0F:  MOVWF  57
0B10:  MOVLW  18
0B11:  MOVWF  58
0B12:  BCF    0A.3
0B13:  CALL   5FB
0B14:  BSF    0A.3
....................    printf (nokia_printchar, "/"); 
0B15:  MOVLW  2F
0B16:  MOVWF  5D
0B17:  BCF    0A.3
0B18:  CALL   4C3
0B19:  BSF    0A.3
....................    if(num_edit==2) 
0B1A:  MOVF   2B,W
0B1B:  SUBLW  02
0B1C:  BTFSS  03.2
0B1D:  GOTO   34B
....................       if(y<10) 
0B1E:  MOVF   54,W
0B1F:  SUBLW  09
0B20:  BTFSS  03.0
0B21:  GOTO   339
....................          printf (nokia_printchar_inverted, "200%d",y); 
0B22:  MOVLW  32
0B23:  MOVWF  5D
0B24:  BCF    0A.3
0B25:  CALL   6ED
0B26:  BSF    0A.3
0B27:  MOVLW  30
0B28:  MOVWF  5D
0B29:  BCF    0A.3
0B2A:  CALL   6ED
0B2B:  BSF    0A.3
0B2C:  MOVLW  30
0B2D:  MOVWF  5D
0B2E:  BCF    0A.3
0B2F:  CALL   6ED
0B30:  BSF    0A.3
0B31:  MOVF   54,W
0B32:  MOVWF  57
0B33:  MOVLW  18
0B34:  MOVWF  58
0B35:  BCF    0A.3
0B36:  CALL   782
0B37:  BSF    0A.3
0B38:  GOTO   34A
....................       else  
....................          printf (nokia_printchar_inverted, "20%d",y); 
0B39:  MOVLW  32
0B3A:  MOVWF  5D
0B3B:  BCF    0A.3
0B3C:  CALL   6ED
0B3D:  BSF    0A.3
0B3E:  MOVLW  30
0B3F:  MOVWF  5D
0B40:  BCF    0A.3
0B41:  CALL   6ED
0B42:  BSF    0A.3
0B43:  MOVF   54,W
0B44:  MOVWF  57
0B45:  MOVLW  18
0B46:  MOVWF  58
0B47:  BCF    0A.3
0B48:  CALL   782
0B49:  BSF    0A.3
0B4A:  GOTO   377
....................    else  
....................       if(y<10) 
0B4B:  MOVF   54,W
0B4C:  SUBLW  09
0B4D:  BTFSS  03.0
0B4E:  GOTO   366
....................          printf (nokia_printchar, "200%d",y); 
0B4F:  MOVLW  32
0B50:  MOVWF  5D
0B51:  BCF    0A.3
0B52:  CALL   4C3
0B53:  BSF    0A.3
0B54:  MOVLW  30
0B55:  MOVWF  5D
0B56:  BCF    0A.3
0B57:  CALL   4C3
0B58:  BSF    0A.3
0B59:  MOVLW  30
0B5A:  MOVWF  5D
0B5B:  BCF    0A.3
0B5C:  CALL   4C3
0B5D:  BSF    0A.3
0B5E:  MOVF   54,W
0B5F:  MOVWF  57
0B60:  MOVLW  18
0B61:  MOVWF  58
0B62:  BCF    0A.3
0B63:  CALL   5FB
0B64:  BSF    0A.3
0B65:  GOTO   377
....................       else  
....................          printf (nokia_printchar, "20%d",y); 
0B66:  MOVLW  32
0B67:  MOVWF  5D
0B68:  BCF    0A.3
0B69:  CALL   4C3
0B6A:  BSF    0A.3
0B6B:  MOVLW  30
0B6C:  MOVWF  5D
0B6D:  BCF    0A.3
0B6E:  CALL   4C3
0B6F:  BSF    0A.3
0B70:  MOVF   54,W
0B71:  MOVWF  57
0B72:  MOVLW  18
0B73:  MOVWF  58
0B74:  BCF    0A.3
0B75:  CALL   5FB
0B76:  BSF    0A.3
....................    nokia_gotoxy (0, 3); 
0B77:  CLRF   58
0B78:  MOVLW  03
0B79:  MOVWF  59
0B7A:  BCF    0A.3
0B7B:  CALL   419
0B7C:  BSF    0A.3
....................    if(num_edit==3){ 
0B7D:  MOVF   2B,W
0B7E:  SUBLW  03
0B7F:  BTFSS  03.2
0B80:  GOTO   3DB
....................       switch(dayow){ 
0B81:  MOVF   55,W
0B82:  XORLW  01
0B83:  BTFSC  03.2
0B84:  GOTO   395
0B85:  XORLW  03
0B86:  BTFSC  03.2
0B87:  GOTO   39F
0B88:  XORLW  01
0B89:  BTFSC  03.2
0B8A:  GOTO   3A9
0B8B:  XORLW  07
0B8C:  BTFSC  03.2
0B8D:  GOTO   3B3
0B8E:  XORLW  01
0B8F:  BTFSC  03.2
0B90:  GOTO   3BD
0B91:  XORLW  03
0B92:  BTFSC  03.2
0B93:  GOTO   3C7
0B94:  GOTO   3D1
....................          case 1:  
....................          printf (nokia_printchar_inverted, "Sunday        "); 
0B95:  MOVLW  ED
0B96:  BSF    03.6
0B97:  MOVWF  0D
0B98:  MOVLW  02
0B99:  MOVWF  0F
0B9A:  BCF    0A.3
0B9B:  BCF    03.6
0B9C:  CALL   72C
0B9D:  BSF    0A.3
....................          break; 
0B9E:  GOTO   3DA
....................          case 2:  
....................          printf (nokia_printchar_inverted, "Monday        "); 
0B9F:  MOVLW  F5
0BA0:  BSF    03.6
0BA1:  MOVWF  0D
0BA2:  MOVLW  02
0BA3:  MOVWF  0F
0BA4:  BCF    0A.3
0BA5:  BCF    03.6
0BA6:  CALL   72C
0BA7:  BSF    0A.3
....................          break; 
0BA8:  GOTO   3DA
....................          case 3:  
....................          printf (nokia_printchar_inverted, "Tuesday       "); 
0BA9:  MOVLW  FD
0BAA:  BSF    03.6
0BAB:  MOVWF  0D
0BAC:  MOVLW  02
0BAD:  MOVWF  0F
0BAE:  BCF    0A.3
0BAF:  BCF    03.6
0BB0:  CALL   72C
0BB1:  BSF    0A.3
....................          break; 
0BB2:  GOTO   3DA
....................          case 4:  
....................          printf (nokia_printchar_inverted, "Wednesnday    "); 
0BB3:  MOVLW  05
0BB4:  BSF    03.6
0BB5:  MOVWF  0D
0BB6:  MOVLW  03
0BB7:  MOVWF  0F
0BB8:  BCF    0A.3
0BB9:  BCF    03.6
0BBA:  CALL   72C
0BBB:  BSF    0A.3
....................          break; 
0BBC:  GOTO   3DA
....................          case 5:  
....................          printf (nokia_printchar_inverted, "Thursday      "); 
0BBD:  MOVLW  0D
0BBE:  BSF    03.6
0BBF:  MOVWF  0D
0BC0:  MOVLW  03
0BC1:  MOVWF  0F
0BC2:  BCF    0A.3
0BC3:  BCF    03.6
0BC4:  CALL   72C
0BC5:  BSF    0A.3
....................          break;   
0BC6:  GOTO   3DA
....................          case 6:  
....................          printf (nokia_printchar_inverted, "Friday        "); 
0BC7:  MOVLW  15
0BC8:  BSF    03.6
0BC9:  MOVWF  0D
0BCA:  MOVLW  03
0BCB:  MOVWF  0F
0BCC:  BCF    0A.3
0BCD:  BCF    03.6
0BCE:  CALL   72C
0BCF:  BSF    0A.3
....................          break; 
0BD0:  GOTO   3DA
....................          default:  
....................          printf (nokia_printchar_inverted, "Saturday      "); 
0BD1:  MOVLW  1D
0BD2:  BSF    03.6
0BD3:  MOVWF  0D
0BD4:  MOVLW  03
0BD5:  MOVWF  0F
0BD6:  BCF    0A.3
0BD7:  BCF    03.6
0BD8:  CALL   72C
0BD9:  BSF    0A.3
....................          break;       
....................       } 
....................    } 
0BDA:  GOTO   434
....................    else{  
....................        switch(dow){ 
0BDB:  MOVF   43,W
0BDC:  XORLW  01
0BDD:  BTFSC  03.2
0BDE:  GOTO   3EF
0BDF:  XORLW  03
0BE0:  BTFSC  03.2
0BE1:  GOTO   3F9
0BE2:  XORLW  01
0BE3:  BTFSC  03.2
0BE4:  GOTO   403
0BE5:  XORLW  07
0BE6:  BTFSC  03.2
0BE7:  GOTO   40D
0BE8:  XORLW  01
0BE9:  BTFSC  03.2
0BEA:  GOTO   417
0BEB:  XORLW  03
0BEC:  BTFSC  03.2
0BED:  GOTO   421
0BEE:  GOTO   42B
....................          case 1:  
....................          printf (nokia_printchar, "Sunday         "); 
0BEF:  MOVLW  25
0BF0:  BSF    03.6
0BF1:  MOVWF  0D
0BF2:  MOVLW  03
0BF3:  MOVWF  0F
0BF4:  BCF    0A.3
0BF5:  BCF    03.6
0BF6:  CALL   4FE
0BF7:  BSF    0A.3
....................          break; 
0BF8:  GOTO   434
....................          case 2:  
....................          printf (nokia_printchar, "Monday         "); 
0BF9:  MOVLW  2D
0BFA:  BSF    03.6
0BFB:  MOVWF  0D
0BFC:  MOVLW  03
0BFD:  MOVWF  0F
0BFE:  BCF    0A.3
0BFF:  BCF    03.6
0C00:  CALL   4FE
0C01:  BSF    0A.3
....................          break; 
0C02:  GOTO   434
....................          case 3:  
....................          printf (nokia_printchar, "Tuesday        "); 
0C03:  MOVLW  35
0C04:  BSF    03.6
0C05:  MOVWF  0D
0C06:  MOVLW  03
0C07:  MOVWF  0F
0C08:  BCF    0A.3
0C09:  BCF    03.6
0C0A:  CALL   4FE
0C0B:  BSF    0A.3
....................          break; 
0C0C:  GOTO   434
....................          case 4:  
....................          printf (nokia_printchar, "Wednesnday     "); 
0C0D:  MOVLW  3D
0C0E:  BSF    03.6
0C0F:  MOVWF  0D
0C10:  MOVLW  03
0C11:  MOVWF  0F
0C12:  BCF    0A.3
0C13:  BCF    03.6
0C14:  CALL   4FE
0C15:  BSF    0A.3
....................          break; 
0C16:  GOTO   434
....................          case 5:  
....................          printf (nokia_printchar, "Thursday       "); 
0C17:  MOVLW  45
0C18:  BSF    03.6
0C19:  MOVWF  0D
0C1A:  MOVLW  03
0C1B:  MOVWF  0F
0C1C:  BCF    0A.3
0C1D:  BCF    03.6
0C1E:  CALL   4FE
0C1F:  BSF    0A.3
....................          break;   
0C20:  GOTO   434
....................          case 6:  
....................          printf (nokia_printchar, "Friday         "); 
0C21:  MOVLW  4D
0C22:  BSF    03.6
0C23:  MOVWF  0D
0C24:  MOVLW  03
0C25:  MOVWF  0F
0C26:  BCF    0A.3
0C27:  BCF    03.6
0C28:  CALL   4FE
0C29:  BSF    0A.3
....................          break; 
0C2A:  GOTO   434
....................          default:  
....................          printf (nokia_printchar, "Saturday       "); 
0C2B:  MOVLW  55
0C2C:  BSF    03.6
0C2D:  MOVWF  0D
0C2E:  MOVLW  03
0C2F:  MOVWF  0F
0C30:  BCF    0A.3
0C31:  BCF    03.6
0C32:  CALL   4FE
0C33:  BSF    0A.3
....................          break;       
....................       }      
....................    } 
....................    button_ok(2); 
0C34:  MOVLW  02
0C35:  MOVWF  57
0C36:  BCF    0A.3
0C37:  CALL   6A9
0C38:  BSF    0A.3
.................... } 
....................  
.................... void control_time(){//dieu khien nut bam 
....................       if(!input(MODE)){ 
*
1000:  BSF    03.5
1001:  BSF    06.0
1002:  BCF    03.5
1003:  BTFSC  06.0
1004:  GOTO   0A2
....................          while(!input(MODE)){ 
1005:  BSF    03.5
1006:  BSF    06.0
1007:  BCF    03.5
1008:  BTFSC  06.0
1009:  GOTO   010
....................             delay_ms(100); 
100A:  MOVLW  64
100B:  MOVWF  54
100C:  BCF    0A.4
100D:  CALL   3D5
100E:  BSF    0A.4
100F:  GOTO   005
....................          } 
....................          if(clock_mode==0){//neu dang o man hinh lock thi chuyen sang menu 
1010:  MOVF   28,F
1011:  BTFSS  03.2
1012:  GOTO   017
....................             clock_mode=1; 
1013:  MOVLW  01
1014:  MOVWF  28
....................             mode_list=0;//chuyen danh sach ve 0 
1015:  CLRF   2C
....................          } 
1016:  GOTO   09D
....................          else if(clock_mode==1){ 
1017:  DECFSZ 28,W
1018:  GOTO   09D
....................             if(setting_mode==0){//neu dang o man hinh danh sach thi chuyen sang man hinh khac 
1019:  MOVF   29,F
101A:  BTFSS  03.2
101B:  GOTO   020
....................                setting_mode=mode_list+1;//chuyen sang man hinh con 
101C:  MOVLW  01
101D:  ADDWF  2C,W
101E:  MOVWF  29
....................             }else if(setting_mode==1){ 
101F:  GOTO   09D
1020:  DECFSZ 29,W
1021:  GOTO   045
....................             if(set_time_mode==0) 
1022:  MOVF   4A,F
1023:  BTFSS  03.2
1024:  GOTO   028
....................             set_time_mode=1;//chuyen sang man hinh luu cai dat 
1025:  MOVLW  01
1026:  MOVWF  4A
1027:  GOTO   044
....................             else{ 
....................                h=h_edit;//neu dang o man hinh chinh thoi gian thi luu gio 
1028:  MOVF   3A,W
1029:  MOVWF  37
....................                m=m_edit;//luu phut da chinh 
102A:  MOVF   3B,W
102B:  MOVWF  38
....................                log_screen(0);//man hinh thong bao da luu                
102C:  CLRF   52
102D:  BCF    0A.4
102E:  CALL   554
102F:  BSF    0A.4
....................                setting_mode=0;//chuyen ve man hinh menu 
1030:  CLRF   29
....................                rtc_set_datetime(day,mth,yea,dow,h,m);//luu thoi gian da chinh 
1031:  MOVF   40,W
1032:  MOVWF  52
1033:  MOVF   41,W
1034:  MOVWF  53
1035:  MOVF   42,W
1036:  MOVWF  54
1037:  MOVF   43,W
1038:  MOVWF  55
1039:  MOVF   37,W
103A:  MOVWF  56
103B:  MOVF   38,W
103C:  MOVWF  57
103D:  BCF    0A.4
103E:  CALL   5B5
103F:  BSF    0A.4
....................                nokia_clean_ddram () ; 
1040:  BCF    0A.4
1041:  CALL   43A
1042:  BSF    0A.4
....................                set_time_mode=0;//thoat man hinh cai dat 
1043:  CLRF   4A
....................             } 
....................             }else if(setting_mode==2){ 
1044:  GOTO   09D
1045:  MOVF   29,W
1046:  SUBLW  02
1047:  BTFSS  03.2
1048:  GOTO   06E
....................             if(set_date_mode==0) 
1049:  MOVF   4B,F
104A:  BTFSS  03.2
104B:  GOTO   04F
....................                set_date_mode=1;//chuyen sang man hinh luu cai dat 
104C:  MOVLW  01
104D:  MOVWF  4B
104E:  GOTO   06D
....................             else{ 
....................                day=day_edit;//neu dang o man hinh chinh ngay thang nam thi luu 
104F:  MOVF   3C,W
1050:  MOVWF  40
....................                mth=mth_edit;// lai gia tri da chinh 
1051:  MOVF   3D,W
1052:  MOVWF  41
....................                yea=yea_edit; 
1053:  MOVF   3E,W
1054:  MOVWF  42
....................                dow=dow_edit; 
1055:  MOVF   3F,W
1056:  MOVWF  43
....................                log_screen(1);//man hinh thong bao da luu                
1057:  MOVLW  01
1058:  MOVWF  52
1059:  BCF    0A.4
105A:  CALL   554
105B:  BSF    0A.4
....................                setting_mode=0;//chuyen ve man hinh menu 
105C:  CLRF   29
....................                rtc_set_datetime(day,mth,yea,dow,h,m);//luu lai thoi gian da chinh 
105D:  MOVF   40,W
105E:  MOVWF  52
105F:  MOVF   41,W
1060:  MOVWF  53
1061:  MOVF   42,W
1062:  MOVWF  54
1063:  MOVF   43,W
1064:  MOVWF  55
1065:  MOVF   37,W
1066:  MOVWF  56
1067:  MOVF   38,W
1068:  MOVWF  57
1069:  BCF    0A.4
106A:  CALL   5B5
106B:  BSF    0A.4
....................                set_date_mode=0;//thoat man hinh cai dat 
106C:  CLRF   4B
....................             } 
....................             }else if(setting_mode==3){ 
106D:  GOTO   09D
106E:  MOVF   29,W
106F:  SUBLW  03
1070:  BTFSS  03.2
1071:  GOTO   09D
....................                if(alarm_mode==0){//neu dang o man hinh danh sach alarm thi chuyen 
1072:  MOVF   2A,F
1073:  BTFSS  03.2
1074:  GOTO   079
....................                   alarm_mode=mode_list+1;//sang man hinh chinh alarm                   
1075:  MOVLW  01
1076:  ADDWF  2C,W
1077:  MOVWF  2A
....................                }else{ 
1078:  GOTO   09D
....................                   if(set_alarm_mode==0){//neu dang o man hinh danh sach thi 
1079:  MOVF   49,F
107A:  BTFSS  03.2
107B:  GOTO   080
....................                      set_alarm_mode=mode_list+1;//luu cai dat thoi gian                      
107C:  MOVLW  01
107D:  ADDWF  2C,W
107E:  MOVWF  49
....................                   } 
107F:  GOTO   09D
....................                   else if(set_alarm_mode==1){ 
1080:  DECFSZ 49,W
1081:  GOTO   091
....................                         set_alarm[alarm_mode-1]=1;//set alarm on 
1082:  MOVLW  01
1083:  SUBWF  2A,W
1084:  ADDLW  44
1085:  MOVWF  04
1086:  BCF    03.7
1087:  MOVLW  01
1088:  MOVWF  00
....................                         alarm_mode=0;//thoat man hinh chinh alarm 
1089:  CLRF   2A
....................                         set_alarm_mode=0;//thoat man hinh set alarm 
108A:  CLRF   49
....................                         log_screen(2); //man hinh thong bao da luu 
108B:  MOVLW  02
108C:  MOVWF  52
108D:  BCF    0A.4
108E:  CALL   554
108F:  BSF    0A.4
....................                   }else if(set_alarm_mode==2){  
1090:  GOTO   09D
1091:  MOVF   49,W
1092:  SUBLW  02
1093:  BTFSS  03.2
1094:  GOTO   09D
....................                         set_alarm[alarm_mode-1]=0;//set alarm off 
1095:  MOVLW  01
1096:  SUBWF  2A,W
1097:  ADDLW  44
1098:  MOVWF  04
1099:  BCF    03.7
109A:  CLRF   00
....................                         alarm_mode=0; 
109B:  CLRF   2A
....................                         set_alarm_mode=0;                         
109C:  CLRF   49
....................                   } 
....................                } 
....................             } 
....................          } 
....................          mode_list=0;//chinh danh sach ve dau 
109D:  CLRF   2C
....................          num_edit=0;//thu tu edit ve dau 
109E:  CLRF   2B
....................          nokia_clean_ddram () ;//xoa man hinh 
109F:  BCF    0A.4
10A0:  CALL   43A
10A1:  BSF    0A.4
....................       } 
....................        
....................       if(!input(EDIT)){ 
10A2:  BSF    03.5
10A3:  BSF    08.0
10A4:  BCF    03.5
10A5:  BTFSC  08.0
10A6:  GOTO   0F2
....................          while(!input(EDIT)){ 
10A7:  BSF    03.5
10A8:  BSF    08.0
10A9:  BCF    03.5
10AA:  BTFSC  08.0
10AB:  GOTO   0B2
....................             delay_ms(10); 
10AC:  MOVLW  0A
10AD:  MOVWF  54
10AE:  BCF    0A.4
10AF:  CALL   3D5
10B0:  BSF    0A.4
10B1:  GOTO   0A7
....................             //printf("point 1\n"); 
....................          } 
....................          if(clock_mode==1){ 
10B2:  DECFSZ 28,W
10B3:  GOTO   0EF
....................             if(setting_mode==0){//dang o man hinh danh sach 
10B4:  MOVF   29,F
10B5:  BTFSS  03.2
10B6:  GOTO   0B9
....................                clock_mode=0;//ve man hinh chinh 
10B7:  CLRF   28
....................             } 
10B8:  GOTO   0EF
....................             else if(setting_mode==1){//dang o man hinh chinh thoi gian 
10B9:  DECFSZ 29,W
10BA:  GOTO   0C8
....................             if(set_time_mode==0){ 
10BB:  MOVF   4A,F
10BC:  BTFSS  03.2
10BD:  GOTO   0C4
....................                num_edit++;//thay thoi so can chinh 
10BE:  INCF   2B,F
....................                if(num_edit>1)num_edit=0; 
10BF:  MOVF   2B,W
10C0:  SUBLW  01
10C1:  BTFSS  03.0
10C2:  CLRF   2B
....................             } 
10C3:  GOTO   0C7
....................             else{ 
....................                setting_mode=0;//ve man hinh danh sach 
10C4:  CLRF   29
....................                mode_list=0; 
10C5:  CLRF   2C
....................                set_time_mode=0;//thoat man hinh chinh thoi gian 
10C6:  CLRF   4A
....................             } 
....................             } 
10C7:  GOTO   0EF
....................             else if(setting_mode==2){//man hinh chinh ngay 
10C8:  MOVF   29,W
10C9:  SUBLW  02
10CA:  BTFSS  03.2
10CB:  GOTO   0DA
....................             if(set_date_mode==0){ 
10CC:  MOVF   4B,F
10CD:  BTFSS  03.2
10CE:  GOTO   0D5
....................                num_edit++; 
10CF:  INCF   2B,F
....................                if(num_edit>3)num_edit=0; 
10D0:  MOVF   2B,W
10D1:  SUBLW  03
10D2:  BTFSS  03.0
10D3:  CLRF   2B
....................             } 
10D4:  GOTO   0D9
....................             else{ 
....................                set_date_mode=0; 
10D5:  CLRF   4B
....................                setting_mode=0; 
10D6:  CLRF   29
....................                mode_list=1; 
10D7:  MOVLW  01
10D8:  MOVWF  2C
....................             } 
....................             } 
10D9:  GOTO   0EF
....................             else{ 
....................                if(alarm_mode==0){//man hinh danh sach alarm 
10DA:  MOVF   2A,F
10DB:  BTFSS  03.2
10DC:  GOTO   0E1
....................                   setting_mode=0;//thoat man hinh 
10DD:  CLRF   29
....................                   mode_list=2; 
10DE:  MOVLW  02
10DF:  MOVWF  2C
....................                } 
10E0:  GOTO   0EF
....................                else{ 
....................                   if(set_alarm_mode==0){ 
10E1:  MOVF   49,F
10E2:  BTFSS  03.2
10E3:  GOTO   0EA
....................                      num_edit++; 
10E4:  INCF   2B,F
....................                      if(num_edit>1)num_edit=0;                          
10E5:  MOVF   2B,W
10E6:  SUBLW  01
10E7:  BTFSS  03.0
10E8:  CLRF   2B
....................                   } 
10E9:  GOTO   0EF
....................                   else{ 
....................                      set_alarm_mode=0; 
10EA:  CLRF   49
....................                      alarm_mode=0; 
10EB:  CLRF   2A
....................                      setting_mode=0; 
10EC:  CLRF   29
....................                      mode_list=2; 
10ED:  MOVLW  02
10EE:  MOVWF  2C
....................                   } 
....................                } 
....................             } 
....................          }       
....................          nokia_clean_ddram () ; 
10EF:  BCF    0A.4
10F0:  CALL   43A
10F1:  BSF    0A.4
.................... //         printf("point 1\n"); 
.................... //         delayled_on(1); 
....................       } 
....................        
....................       if(!input(INC)){          
10F2:  BSF    03.5
10F3:  BSF    08.2
10F4:  BCF    03.5
10F5:  BTFSC  08.2
10F6:  GOTO   19D
....................          while(!input(INC)){             
10F7:  BSF    03.5
10F8:  BSF    08.2
10F9:  BCF    03.5
10FA:  BTFSC  08.2
10FB:  GOTO   19D
....................             if(clock_mode==1){ 
10FC:  DECFSZ 28,W
10FD:  GOTO   18B
....................                if(setting_mode==0){ 
10FE:  MOVF   29,F
10FF:  BTFSS  03.2
1100:  GOTO   107
....................                   mode_list++; 
1101:  INCF   2C,F
....................                   if(mode_list>2)mode_list=0; 
1102:  MOVF   2C,W
1103:  SUBLW  02
1104:  BTFSS  03.0
1105:  CLRF   2C
....................                }             
1106:  GOTO   18B
....................                else if(setting_mode==1){ 
1107:  DECFSZ 29,W
1108:  GOTO   11B
....................                if(set_time_mode==0) 
1109:  MOVF   4A,F
110A:  BTFSS  03.2
110B:  GOTO   11A
....................                   if(num_edit==0){ 
110C:  MOVF   2B,F
110D:  BTFSS  03.2
110E:  GOTO   115
....................                      h_edit++; 
110F:  INCF   3A,F
....................                      if(h_edit>23)h_edit=0;                      
1110:  MOVF   3A,W
1111:  SUBLW  17
1112:  BTFSS  03.0
1113:  CLRF   3A
....................                   }else{ 
1114:  GOTO   11A
....................                      m_edit++; 
1115:  INCF   3B,F
....................                      if(m_edit>59) m_edit=0;    
1116:  MOVF   3B,W
1117:  SUBLW  3B
1118:  BTFSS  03.0
1119:  CLRF   3B
....................                   } 
....................                } 
111A:  GOTO   18B
....................                else if(setting_mode==2){ 
111B:  MOVF   29,W
111C:  SUBLW  02
111D:  BTFSS  03.2
111E:  GOTO   144
....................                if(set_date_mode==0) 
111F:  MOVF   4B,F
1120:  BTFSS  03.2
1121:  GOTO   143
....................                   switch(num_edit){ 
1122:  MOVF   2B,W
1123:  ADDLW  FC
1124:  BTFSC  03.0
1125:  GOTO   143
1126:  ADDLW  04
1127:  GOTO   253
....................                      case 0:day_edit++; 
1128:  INCF   3C,F
....................                            if(day_edit>31)day_edit=1; 
1129:  MOVF   3C,W
112A:  SUBLW  1F
112B:  BTFSC  03.0
112C:  GOTO   12F
112D:  MOVLW  01
112E:  MOVWF  3C
....................                            break; 
112F:  GOTO   143
....................                      case 1:mth_edit++; 
1130:  INCF   3D,F
....................                            if(mth_edit>12)mth_edit=0; 
1131:  MOVF   3D,W
1132:  SUBLW  0C
1133:  BTFSS  03.0
1134:  CLRF   3D
....................                            break; 
1135:  GOTO   143
....................                      case 2:yea_edit++; 
1136:  INCF   3E,F
....................                            if(yea_edit>99)yea_edit=0; 
1137:  MOVF   3E,W
1138:  SUBLW  63
1139:  BTFSS  03.0
113A:  CLRF   3E
....................                            break; 
113B:  GOTO   143
....................                      case 3:dow_edit++; 
113C:  INCF   3F,F
....................                            if(dow_edit>7)dow_edit=1; 
113D:  MOVF   3F,W
113E:  SUBLW  07
113F:  BTFSC  03.0
1140:  GOTO   143
1141:  MOVLW  01
1142:  MOVWF  3F
....................                            break; 
....................                   } 
....................                } 
1143:  GOTO   18B
....................                else if(setting_mode==3){ 
1144:  MOVF   29,W
1145:  SUBLW  03
1146:  BTFSS  03.2
1147:  GOTO   18B
....................                   if(alarm_mode==0){//khi dang o man hinh danh sach cac alarm 
1148:  MOVF   2A,F
1149:  BTFSS  03.2
114A:  GOTO   151
....................                      mode_list++; 
114B:  INCF   2C,F
....................                      if(mode_list>4)mode_list=0;    
114C:  MOVF   2C,W
114D:  SUBLW  04
114E:  BTFSS  03.0
114F:  CLRF   2C
....................                   } 
1150:  GOTO   18B
....................                   else{ 
....................                      if(set_alarm_mode==0){//khi dang chinh thoi gian 
1151:  MOVF   49,F
1152:  BTFSS  03.2
1153:  GOTO   183
....................                         if(num_edit==0){ 
1154:  MOVF   2B,F
1155:  BTFSS  03.2
1156:  GOTO   16D
....................                            h_alarm[alarm_mode-1]++; 
1157:  MOVLW  01
1158:  SUBWF  2A,W
1159:  ADDLW  2D
115A:  MOVWF  04
115B:  BCF    03.7
115C:  INCF   00,F
....................                            if(h_alarm[alarm_mode-1]>23)h_alarm[alarm_mode-1]=0;                      
115D:  MOVLW  01
115E:  SUBWF  2A,W
115F:  ADDLW  2D
1160:  MOVWF  04
1161:  BCF    03.7
1162:  MOVF   00,W
1163:  SUBLW  17
1164:  BTFSC  03.0
1165:  GOTO   16C
1166:  MOVLW  01
1167:  SUBWF  2A,W
1168:  ADDLW  2D
1169:  MOVWF  04
116A:  BCF    03.7
116B:  CLRF   00
....................                         }else{ 
116C:  GOTO   182
....................                            m_alarm[alarm_mode-1]++; 
116D:  MOVLW  01
116E:  SUBWF  2A,W
116F:  ADDLW  32
1170:  MOVWF  04
1171:  BCF    03.7
1172:  INCF   00,F
....................                            if(m_alarm[alarm_mode-1]>59) m_alarm[alarm_mode-1]=0;    
1173:  MOVLW  01
1174:  SUBWF  2A,W
1175:  ADDLW  32
1176:  MOVWF  04
1177:  BCF    03.7
1178:  MOVF   00,W
1179:  SUBLW  3B
117A:  BTFSC  03.0
117B:  GOTO   182
117C:  MOVLW  01
117D:  SUBWF  2A,W
117E:  ADDLW  32
117F:  MOVWF  04
1180:  BCF    03.7
1181:  CLRF   00
....................                         }           
....................                      } 
1182:  GOTO   18B
....................                      else{// khi dang tuy chon set hay khong 
....................                         mode_list++; 
1183:  INCF   2C,F
....................                         if(mode_list>1)mode_list=0; 
1184:  MOVF   2C,W
1185:  SUBLW  01
1186:  BTFSS  03.0
1187:  CLRF   2C
....................                         set_alarm_mode=mode_list+1; 
1188:  MOVLW  01
1189:  ADDWF  2C,W
118A:  MOVWF  49
....................                      } 
....................                   } 
....................               
....................                }  
....................              
....................             } 
....................             nokia_clean_ddram () ; 
118B:  BCF    0A.4
118C:  CALL   43A
118D:  BSF    0A.4
....................             display_screen(); 
118E:  BCF    0A.4
118F:  BSF    0A.3
1190:  CALL   0D4
1191:  BSF    0A.4
1192:  BCF    0A.3
....................             delay_ms(500); 
1193:  MOVLW  02
1194:  MOVWF  52
1195:  MOVLW  FA
1196:  MOVWF  54
1197:  BCF    0A.4
1198:  CALL   3D5
1199:  BSF    0A.4
119A:  DECFSZ 52,F
119B:  GOTO   195
119C:  GOTO   0F7
....................          }          
....................       } 
....................        
....................       if(!input(DEC)){          
119D:  BSF    03.5
119E:  BSF    08.3
119F:  BCF    03.5
11A0:  BTFSC  08.3
11A1:  GOTO   250
....................          while(!input(DEC)){                         
11A2:  BSF    03.5
11A3:  BSF    08.3
11A4:  BCF    03.5
11A5:  BTFSC  08.3
11A6:  GOTO   250
....................             if(clock_mode==1){ 
11A7:  DECFSZ 28,W
11A8:  GOTO   23E
....................                if(setting_mode==0){                   
11A9:  MOVF   29,F
11AA:  BTFSS  03.2
11AB:  GOTO   1B4
....................                   if(mode_list==0)mode_list=2; 
11AC:  MOVF   2C,F
11AD:  BTFSS  03.2
11AE:  GOTO   1B2
11AF:  MOVLW  02
11B0:  MOVWF  2C
11B1:  GOTO   1B3
....................                   else mode_list--; 
11B2:  DECF   2C,F
....................                }             
11B3:  GOTO   23E
....................                else if(setting_mode==1){ 
11B4:  DECFSZ 29,W
11B5:  GOTO   1C9
....................                   if(num_edit==0){                      
11B6:  MOVF   2B,F
11B7:  BTFSS  03.2
11B8:  GOTO   1C1
....................                      if(h_edit==0)h_edit=23;     
11B9:  MOVF   3A,F
11BA:  BTFSS  03.2
11BB:  GOTO   1BF
11BC:  MOVLW  17
11BD:  MOVWF  3A
11BE:  GOTO   1C0
....................                      else h_edit--; 
11BF:  DECF   3A,F
....................                   }else{ 
11C0:  GOTO   1C8
....................                      if(m_edit==0) m_edit=59; 
11C1:  MOVF   3B,F
11C2:  BTFSS  03.2
11C3:  GOTO   1C7
11C4:  MOVLW  3B
11C5:  MOVWF  3B
11C6:  GOTO   1C8
....................                      else m_edit--;                         
11C7:  DECF   3B,F
....................                   } 
....................                } 
11C8:  GOTO   23E
....................                else if(setting_mode==2){ 
11C9:  MOVF   29,W
11CA:  SUBLW  02
11CB:  BTFSS  03.2
11CC:  GOTO   1F1
....................                   switch(num_edit){ 
11CD:  MOVF   2B,W
11CE:  ADDLW  FC
11CF:  BTFSC  03.0
11D0:  GOTO   1F0
11D1:  ADDLW  04
11D2:  GOTO   25B
....................                      case 0: 
....................                            if(day_edit==0)day_edit=31; 
11D3:  MOVF   3C,F
11D4:  BTFSS  03.2
11D5:  GOTO   1D9
11D6:  MOVLW  1F
11D7:  MOVWF  3C
11D8:  GOTO   1DA
....................                            else day_edit--; 
11D9:  DECF   3C,F
....................                            break; 
11DA:  GOTO   1F0
....................                      case 1: 
....................                            if(mth_edit==0)mth_edit=2; 
11DB:  MOVF   3D,F
11DC:  BTFSS  03.2
11DD:  GOTO   1E1
11DE:  MOVLW  02
11DF:  MOVWF  3D
11E0:  GOTO   1E2
....................                            else mth_edit--; 
11E1:  DECF   3D,F
....................                            break; 
11E2:  GOTO   1F0
....................                      case 2: 
....................                            if(yea_edit==0)yea_edit=99; 
11E3:  MOVF   3E,F
11E4:  BTFSS  03.2
11E5:  GOTO   1E8
11E6:  MOVLW  63
11E7:  MOVWF  3E
....................                            yea_edit--; 
11E8:  DECF   3E,F
....................                            break; 
11E9:  GOTO   1F0
....................                      case 3: 
....................                            if(dow_edit==1)dow_edit=7; 
11EA:  DECFSZ 3F,W
11EB:  GOTO   1EF
11EC:  MOVLW  07
11ED:  MOVWF  3F
11EE:  GOTO   1F0
....................                            else dow_edit--; 
11EF:  DECF   3F,F
....................                            break; 
....................                   } 
....................                } 
11F0:  GOTO   23E
....................                else if(setting_mode==3){ 
11F1:  MOVF   29,W
11F2:  SUBLW  03
11F3:  BTFSS  03.2
11F4:  GOTO   23E
....................                   if(alarm_mode==0){                      
11F5:  MOVF   2A,F
11F6:  BTFSS  03.2
11F7:  GOTO   200
....................                      if(mode_list==0)mode_list=4;  
11F8:  MOVF   2C,F
11F9:  BTFSS  03.2
11FA:  GOTO   1FE
11FB:  MOVLW  04
11FC:  MOVWF  2C
11FD:  GOTO   1FF
....................                      else mode_list--; 
11FE:  DECF   2C,F
....................                   } 
11FF:  GOTO   23E
....................                   else{ 
....................                      if(set_alarm_mode==0){ 
1200:  MOVF   49,F
1201:  BTFSS  03.2
1202:  GOTO   234
....................                         if(num_edit==0){                            
1203:  MOVF   2B,F
1204:  BTFSS  03.2
1205:  GOTO   21D
....................                            if(h_alarm[alarm_mode-1]==0)h_alarm[alarm_mode-1]=23; 
1206:  MOVLW  01
1207:  SUBWF  2A,W
1208:  ADDLW  2D
1209:  MOVWF  04
120A:  BCF    03.7
120B:  MOVF   00,F
120C:  BTFSS  03.2
120D:  GOTO   216
120E:  MOVLW  01
120F:  SUBWF  2A,W
1210:  ADDLW  2D
1211:  MOVWF  04
1212:  BCF    03.7
1213:  MOVLW  17
1214:  MOVWF  00
1215:  GOTO   21C
....................                            else h_alarm[alarm_mode-1]--; 
1216:  MOVLW  01
1217:  SUBWF  2A,W
1218:  ADDLW  2D
1219:  MOVWF  04
121A:  BCF    03.7
121B:  DECF   00,F
....................                         }else{                            
121C:  GOTO   233
....................                            if(m_alarm[alarm_mode-1]==0) m_alarm[alarm_mode-1]=59;    
121D:  MOVLW  01
121E:  SUBWF  2A,W
121F:  ADDLW  32
1220:  MOVWF  04
1221:  BCF    03.7
1222:  MOVF   00,F
1223:  BTFSS  03.2
1224:  GOTO   22D
1225:  MOVLW  01
1226:  SUBWF  2A,W
1227:  ADDLW  32
1228:  MOVWF  04
1229:  BCF    03.7
122A:  MOVLW  3B
122B:  MOVWF  00
122C:  GOTO   233
....................                            else m_alarm[alarm_mode-1]--; 
122D:  MOVLW  01
122E:  SUBWF  2A,W
122F:  ADDLW  32
1230:  MOVWF  04
1231:  BCF    03.7
1232:  DECF   00,F
....................                         }           
....................                      } 
1233:  GOTO   23E
....................                      else{                         
....................                         if(mode_list==0)mode_list=1; 
1234:  MOVF   2C,F
1235:  BTFSS  03.2
1236:  GOTO   23A
1237:  MOVLW  01
1238:  MOVWF  2C
1239:  GOTO   23B
....................                         else mode_list--; 
123A:  DECF   2C,F
....................                         set_alarm_mode=mode_list+1; 
123B:  MOVLW  01
123C:  ADDWF  2C,W
123D:  MOVWF  49
....................                      } 
....................                   } 
....................               
....................                }  
....................              
....................             }    
....................             nokia_clean_ddram () ; 
123E:  BCF    0A.4
123F:  CALL   43A
1240:  BSF    0A.4
....................             display_screen(); 
1241:  BCF    0A.4
1242:  BSF    0A.3
1243:  CALL   0D4
1244:  BSF    0A.4
1245:  BCF    0A.3
....................             delay_ms(500); 
1246:  MOVLW  02
1247:  MOVWF  52
1248:  MOVLW  FA
1249:  MOVWF  54
124A:  BCF    0A.4
124B:  CALL   3D5
124C:  BSF    0A.4
124D:  DECFSZ 52,F
124E:  GOTO   248
124F:  GOTO   1A2
....................          } 
....................       } 
1250:  BSF    0A.3
1251:  BCF    0A.4
1252:  GOTO   76F (RETURN)
.................... } 
.................... #endif 
....................  
.................... int ds18b20_read(byte tem); 
.................... void ds18b20_configure(int8 TH, int8 TL, int8 config); 
....................  
.................... /* 
....................  * ds1820_read() 
....................  * Description: reads the ds18x20 device on the 1-wire bus and returns 
....................  *              the temperature 
....................  */ 
....................   
.................... int ds18b20_read(byte tem) { 
*
0E39:  CLRF   53
....................     int8 busy=0, temp1, temp2; 
....................     signed int16 temp3; 
....................     int result; 
....................     onewire_reset();//1ms 
0E3A:  CALL   5D7
....................     onewire_write(0xCC);//512us            //Skip ROM, address all devices 
0E3B:  MOVLW  CC
0E3C:  MOVWF  59
0E3D:  CALL   5F4
....................     onewire_write(0x44);//512us //Start temperature conversion     
0E3E:  MOVLW  44
0E3F:  MOVWF  59
0E40:  CALL   5F4
....................     while(busy == 0){                
0E41:  MOVF   53,F
0E42:  BTFSS  03.2
0E43:  GOTO   648
....................        busy = onewire_read();                 
0E44:  CALL   614
0E45:  MOVF   78,W
0E46:  MOVWF  53
0E47:  GOTO   641
....................     } 
....................     onewire_reset(); 
0E48:  CALL   5D7
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
0E49:  MOVLW  CC
0E4A:  MOVWF  59
0E4B:  CALL   5F4
....................     onewire_write(0xBE);            //Read scratchpad 
0E4C:  MOVLW  BE
0E4D:  MOVWF  59
0E4E:  CALL   5F4
....................     temp1 = onewire_read();//1040us 
0E4F:  CALL   614
0E50:  MOVF   78,W
0E51:  MOVWF  54
....................     temp2 = onewire_read();     
0E52:  CALL   614
0E53:  MOVF   78,W
0E54:  MOVWF  55
....................     temp3 = make16(temp2, temp1); 
0E55:  MOVF   55,W
0E56:  MOVWF  57
0E57:  MOVF   54,W
0E58:  MOVWF  56
....................  
....................     //result = (float) temp3 / 2.0;   //Calculation for DS18S20 with 0.5 deg C resolution 
....................     result = temp3 >> 4;    //Calculation for DS18B20 with 0.1 deg C resolution 
0E59:  RRF    57,W
0E5A:  MOVWF  7A
0E5B:  RRF    56,W
0E5C:  MOVWF  79
0E5D:  RRF    7A,F
0E5E:  RRF    79,F
0E5F:  RRF    7A,F
0E60:  RRF    79,F
0E61:  RRF    7A,F
0E62:  RRF    79,F
0E63:  MOVF   79,W
0E64:  MOVWF  58
....................     return(result); 
0E65:  MOVF   58,W
0E66:  MOVWF  78
0E67:  BSF    0A.3
0E68:  BCF    0A.4
0E69:  GOTO   777 (RETURN)
.................... } 
....................  
.................... /* 
....................  * ds1820_configure(int8 TH, int8 LH, int8 config) 
....................  * Description: writes configuration data to the DS18x20 device 
....................  * Arguments: alarm trigger high, alarm trigger low, configuration 
....................  */ 
....................  
.................... void ds18b20_configure(int8 TH, int8 TL, int8 config) { 
....................     onewire_reset(); 
....................     onewire_write(0xCC);            //Skip ROM, address all devices 
....................     onewire_write(0x4E);            //Write to scratchpad 
....................     onewire_write(TH); 
....................     onewire_write(TL); 
....................     onewire_write(config); 
.................... } 
....................  
.................... #endif /*DS1820_C*/ 
....................  
.................... #include <stdlib.h> // for atoi32 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... void main() 
*
0E9E:  MOVF   03,W
0E9F:  ANDLW  1F
0EA0:  MOVWF  03
0EA1:  CLRF   28
0EA2:  CLRF   29
0EA3:  CLRF   2A
0EA4:  CLRF   2B
0EA5:  CLRF   2C
0EA6:  MOVLW  02
0EA7:  MOVWF  37
0EA8:  MOVLW  04
0EA9:  MOVWF  38
0EAA:  MOVLW  2D
0EAB:  MOVWF  39
0EAC:  MOVLW  09
0EAD:  MOVWF  3A
0EAE:  MOVLW  38
0EAF:  MOVWF  3B
0EB0:  MOVLW  12
0EB1:  MOVWF  3C
0EB2:  MOVLW  06
0EB3:  MOVWF  3D
0EB4:  MOVLW  10
0EB5:  MOVWF  3E
0EB6:  MOVLW  02
0EB7:  MOVWF  3F
0EB8:  MOVLW  05
0EB9:  MOVWF  40
0EBA:  MOVLW  04
0EBB:  MOVWF  41
0EBC:  MOVLW  0F
0EBD:  MOVWF  42
0EBE:  MOVLW  02
0EBF:  MOVWF  43
0EC0:  CLRF   49
0EC1:  CLRF   4A
0EC2:  CLRF   4B
0EC3:  CLRF   4C
0EC4:  BSF    03.5
0EC5:  BSF    03.6
0EC6:  MOVF   09,W
0EC7:  ANDLW  C0
0EC8:  MOVWF  09
0EC9:  BCF    03.6
0ECA:  BCF    1F.4
0ECB:  BCF    1F.5
0ECC:  MOVLW  00
0ECD:  BSF    03.6
0ECE:  MOVWF  08
0ECF:  BCF    03.5
0ED0:  CLRF   07
0ED1:  CLRF   08
0ED2:  CLRF   09
0ED3:  BCF    03.7
*
0EE6:  CLRF   51
.................... { 
....................    byte n=0; 
....................    setup_adc_ports(NO_ANALOGS|VSS_VDD); 
0EE7:  BSF    03.5
0EE8:  BSF    03.6
0EE9:  MOVF   09,W
0EEA:  ANDLW  C0
0EEB:  MOVWF  09
0EEC:  BCF    03.6
0EED:  BCF    1F.4
0EEE:  BCF    1F.5
0EEF:  MOVLW  00
0EF0:  BSF    03.6
0EF1:  MOVWF  08
....................    setup_adc(ADC_OFF); 
0EF2:  BCF    03.5
0EF3:  BCF    03.6
0EF4:  BCF    1F.0
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1); 
0EF5:  BSF    03.5
0EF6:  MOVF   01,W
0EF7:  ANDLW  C7
0EF8:  IORLW  08
0EF9:  MOVWF  01
....................    setup_timer_1(T1_DISABLED); 
0EFA:  BCF    03.5
0EFB:  CLRF   10
....................    setup_timer_2(T2_DISABLED,0,1); 
0EFC:  MOVLW  00
0EFD:  MOVWF  78
0EFE:  MOVWF  12
0EFF:  MOVLW  00
0F00:  BSF    03.5
0F01:  MOVWF  12
....................    setup_comparator(NC_NC_NC_NC); 
0F02:  BCF    03.5
0F03:  BSF    03.6
0F04:  CLRF   07
0F05:  CLRF   08
0F06:  CLRF   09
....................    rtc_init();  
0F07:  BCF    0A.3
0F08:  BCF    03.6
0F09:  GOTO   3B2
0F0A:  BSF    0A.3
....................    nokia_init(); 
0F0B:  BCF    0A.3
0F0C:  GOTO   44F
0F0D:  BSF    0A.3
....................    nokia_clean_ddram() ; 
0F0E:  BCF    0A.3
0F0F:  CALL   43A
0F10:  BSF    0A.3
.................... //   rtc_set_datetime(day,mth,yea,dow,h,m);       
....................     
....................   while(TRUE)  
....................   {    
....................     rtc_get_time(h, m, s);  
....................     rtc_get_date(day,mth,yea,dow); 
....................       control_time(); 
*
0F6C:  BSF    0A.4
0F6D:  BCF    0A.3
0F6E:  GOTO   000
0F6F:  BCF    0A.4
0F70:  BSF    0A.3
....................       if(clock_mode==0){ 
0F71:  MOVF   28,F
0F72:  BTFSS  03.2
0F73:  GOTO   779
....................          temp=ds18b20_read(temp);          
0F74:  MOVF   4C,W
0F75:  MOVWF  52
0F76:  GOTO   639
0F77:  MOVF   78,W
0F78:  MOVWF  4C
....................       } 
....................       //clock_screen(); 
....................       //menu_screen(); 
....................       display_screen(); 
0F79:  CALL   0D4
....................       for(n=0;n<5;n++) 
0F7A:  CLRF   51
0F7B:  MOVF   51,W
0F7C:  SUBLW  04
0F7D:  BTFSS  03.0
0F7E:  GOTO   7A0
....................       if(set_alarm[n]==1) 
0F7F:  MOVLW  44
0F80:  ADDWF  51,W
0F81:  MOVWF  04
0F82:  BCF    03.7
0F83:  DECFSZ 00,W
0F84:  GOTO   79E
....................          if(h==h_alarm[n]) 
0F85:  MOVLW  2D
0F86:  ADDWF  51,W
0F87:  MOVWF  04
0F88:  BCF    03.7
0F89:  MOVF   00,W
0F8A:  SUBWF  37,W
0F8B:  BTFSS  03.2
0F8C:  GOTO   79E
....................            if(m==m_alarm[n]) 
0F8D:  MOVLW  32
0F8E:  ADDWF  51,W
0F8F:  MOVWF  04
0F90:  BCF    03.7
0F91:  MOVF   00,W
0F92:  SUBWF  38,W
0F93:  BTFSS  03.2
0F94:  GOTO   79E
....................             if(s==0){ 
0F95:  MOVF   39,F
0F96:  BTFSS  03.2
0F97:  GOTO   79E
....................                alarm_warning(); 
0F98:  GOTO   66A
....................                set_alarm[n]=0; 
0F99:  MOVLW  44
0F9A:  ADDWF  51,W
0F9B:  MOVWF  04
0F9C:  BCF    03.7
0F9D:  CLRF   00
0F9E:  INCF   51,F
0F9F:  GOTO   77B
....................             }             
0FA0:  GOTO   711
.................... //      printf("day: %d, month: %d, year: %d, day of week: %d\n",day,mth,yea,dow);      
....................   } 
.................... } 
....................  
0FA1:  SLEEP

Configuration Fuses:
   Word  1: 2CE2   HS NOWDT PUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
